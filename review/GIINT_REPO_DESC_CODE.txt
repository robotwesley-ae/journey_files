[REPO_MAP]:

|-- [main.py]
|   |-- Flask app creation
|   |-- Version check
|   |-- Configuration setup
|   |-- Database initialization
|   |-- Route setup
|   |-- App context and server start
|
[.app]
|-- [__init__.py]
|
|-- [routes.py]
|   |-- setup_routes(app)
|       |-- index()
|       |-- chat()
|       |-- register()
|       |-- register_page()
|       |-- settings_page()
|       |-- login()
|       |-- update_key()
|       |-- get_user_state()
|       |-- set_user_state()
|       |-- run()
|       |-- start()
|       |-- list_assistants()
|
|-- [.functions]
|   |-- [__init__.py]
|   |
|   |-- [chat_types.py]
|   |   |-- duo_i(initial_input, agent_1, agent_2, giint_thread, max_iterations)
|   |   |-- x_poll(assistant_ids, team_leader_id, initial_input, giint_thread)
|   |
|   |-- [tools.py]
|   |   |-- giint(arguments, context, giint_thread)
|   |   |-- awaken_assistant(arguments, context, giint_thread)
|   |   |-- giint_flow(arguments, context, giint_thread)
|   |   |-- SDNA_Progenitor(arguments, context, giint_thread)
|   |   |-- SDNA_Chaining(arguments, context, giint_thread)
|   |   |-- SDNA_Morph(arguments, context, giint_thread)
|   |   |-- procreate(domain, context, giint_thread)
|   |
|   |-- [utils.py]
|       |-- get_single_response(response)
|       |-- get_combined_response(response)
|       |-- get_instructions(instruction_names, additional_instructions)
|       |-- get_tools(tool_names)
|       |-- get_schema(agent_type, domain)
|
|-- [.services]
|   |-- [__init__.py]
|   |
|   |-- [chat_services.py]
|   |   |-- render_index()
|   |   |-- render_chat()
|   |   |-- render_register()
|   |   |-- render_settings()
|   |   |-- handle_start(data, config)
|   |   |-- handle_run(data, config)
|   |   |-- handle_list_assistants(data, config)
|   |
|   |-- [openai_client.py]
|   |   |-- OpenAIClientWrapper
|   |       |-- __init__(api_key)
|   |       |-- create_file(file_path, purpose)
|   |       |-- create_assistant(model, name, description, instructions, tools, file_paths, metadata)
|   |       |-- delete_assistant(assistant_id)
|   |       |-- add_assistant_file(assistant_id, file_id)
|   |       |-- get_assistant(assistant_id)
|   |       |-- get_assistant_list(limit, order)
|   |       |-- create_thread()
|   |       |-- add_messages(thread_id, messages)
|   |       |-- get_message_list(thread_id)
|   |       |-- get_message(thread_id, message_id)
|   |       |-- create_run(thread_id, assistant_id)
|   |       |-- get_run(thread_id, run_id)
|   |       |-- submit_tool_outputs(thread_id, run_id, tool_outputs)
|   |       |-- exec_run(thread_id, messages, assistant_id, context, giint_thread)
|   |       |-- thread_and_run(assistant_id, system_message)
|   |
|   |-- [models.py]
|   |   |-- User
|   |       |-- id
|   |       |-- email
|   |       |-- password_hash
|   |       |-- api_key
|   |       |-- state
|   |       |-- set_password(password)
|   |       |-- check_password(password)
|   |       |-- get_state()
|   |       |-- set_state(state_data)
|   |
|   |-- [auth_services.py]
|       |-- generate_token(email, secret_key, expiration)
|       |-- verify_token(token, secret_key)
|       |-- register_user(email, password)
|       |-- login_user(email, password, secret_key)
|       |-- update_api_key(user, api_key)
|
|-- [.giint]
|   |-- [__init__.py]
|   |
|   |-- [giint_agent.py]
|   |   |-- GiintAgent
|   |       |-- __init__(client, agent_id, domain, agent_type, assistant_id, additional_instructions)
|   |       |-- awaken(agent_type, domain, additional_instructions)
|   |       |-- to_json()
|   |       |-- from_json(client, data)
|   |
|   |-- [giint_thread.py]
|   |   |-- GiintThread
|   |       |-- __init__(client, giint_id, main_agent_id, main_thread_id)
|   |       |-- get_context(thread_id)
|   |       |-- add_auxiliary_agent_thread(auxiliary_agent_id)
|   |       |-- remove_auxiliary_agent_thread(auxiliary_agent_id)
|   |       |-- to_json()
|   |       |-- from_json(client, data)
|   |
|   |-- [giint_factories.py]
|   |   |-- GiintAgentFactory
|   |   |   |-- create_agent(client, domain, agent_type, assistant_id, additional_instructions)
|   |   |
|   |   |-- GiintThreadFactory
|   |       |-- create_thread(client, main_agent_id)
|   |
|   |-- [giint_repositories.py]
|       |-- GiintAgentRepository
|       |   |-- save(agent)
|       |   |-- find_by_id(client, agent_id)
|       |   |-- load_agents()
|       |
|       |-- GiintThreadRepository
|           |-- save(thread)
|           |-- find_by_id(client, thread_id)
|           |-- load_threads()
|
|-- [.files]
|   |-- [__init__.py]
|   |
|   |-- [assistant_schema.json]
|   |   |-- main_agent
|   |   |   |-- default
|   |   |       |-- model
|   |   |       |-- name
|   |   |       |-- description
|   |   |       |-- instruction_names
|   |   |       |-- tool_names
|   |   |       |-- file_paths
|   |   |       |-- metadata
|   |   |-- user_proxy_agent
|   |   |   |-- default
|   |   |       |-- (same structure as main_agent)
|   |   |-- duo_agent
|   |   |   |-- default
|   |   |       |-- (same structure as main_agent)
|   |   |-- progeny_agent
|   |   |   |-- default
|   |   |       |-- (same structure as main_agent)
|   |   |-- progenitor_agent
|   |   |   |-- default
|   |   |       |-- (same structure as main_agent)
|   |   |-- chaining_agent
|   |   |   |-- default
|   |   |       |-- (same structure as main_agent)
|   |   |-- morph_agent
|   |       |-- default
|   |           |-- (same structure as main_agent)
|   |
|   |-- [giint_agents.json]
|   |   |-- (agent_id)
|   |       |-- agent_id
|   |       |-- assistant_id
|   |       |-- domain
|   |       |-- agent_type
|   |
|   |-- [giint_threads.json]
|   |   |-- (giint_id)
|   |       |-- giint_id
|   |       |-- main_agent_id
|   |       |-- main_thread_id
|   |       |-- tool_agent_id
|   |       |-- tool_thread_id
|   |       |-- auxiliary_agents_threads
|   |
|   |-- [instructions.json]
|   |   |-- main_agent_instructions
|   |   |-- main_tool_instructions
|   |   |-- duo_agent_instructions
|   |   |-- duo_agent_tool_instructions
|   |   |-- user_proxy_instructions
|   |   |-- user_proxy_tool_instructions
|   |   |-- progeny_agent_instructions
|   |   |-- progenitor_instructions
|   |   |-- chaining_instructions
|   |   |-- morph_instructions
|   |
|   |-- [tools.json]
|       |-- knowledge_retrieval
|       |   |-- type
|       |-- code_interpreter
|       |   |-- type
|       |-- main_tools
|       |   |-- type
|       |   |-- function
|       |       |-- name
|       |       |-- parameters
|       |       |-- description
|       |-- duo_tools
|       |   |-- (same structure as main_tools)
|       |-- user_proxy_tools
|       |   |-- (same structure as main_tools)
|       |-- sdna_progenitor
|       |   |-- (same structure as main_tools)
|       |-- sdna_morph
|           |-- (same structure as main_tools)
|
|-- [.templates]
|   |-- [index.html]
|   |   |-- div.top-banner
|   |   |-- div.login-container
|   |       |-- div.email-input-container
|   |       |-- div.password-container
|   |       |-- button#login-submit
|   |       |-- button#go-to-register
|   |
|   |-- [chat.html]
|   |   |-- div.top-banner#draggable-banner
|   |   |   |-- pre#ascii-logo.ascii-art
|   |   |   |-- div.console-log#console-log
|   |   |   |-- div.resize-handle
|   |   |-- div.main-content
|   |   |   |-- div.chat-window#chat-window-1
|   |   |   |   |-- header.chat-header
|   |   |   |   |-- div.chat-container#chat-container-1
|   |   |   |   |-- div.chat-input-container
|   |   |   |-- button#new-window-button
|   |   |   |-- button#go-to-settings.nav-button
|   |   |   |-- select#saved-windows-dropdown
|   |   |-- div.side-window#side-window
|   |       |-- button.collapse-button#collapse-button
|   |       |-- div.transcript-directory#transcript-directory
|   |       |-- div.transcript-display#transcript-display
|   |           |-- button.back-button#back-button
|   |           |-- div.transcript-messages#transcript-messages
|   |   |-- button.expand-button#expand-button
|   |
|   |-- [register.html]
|   |   |-- div.register-container
|   |       |-- div.email-container
|   |       |-- div.password-container
|   |       |-- button#register-submit
|   |
|   |-- [settings.html]
|        |-- div.settings-container
|            |-- div.api-key-container
|            |-- button#update-api-key
|
|
|-- [.static]
    |-- [api.js]
    |   |-- fetchConsoleMessages()
    |   |-- sendToServer(message, chatWindowNumber, isConsoleMessage)
    |   |-- refreshAssistantList()
    |   |-- fetchTranscripts()
    |   |-- sendTitleToBackend(title)
    |   |-- getUserState(token)
    |   |-- setUserState(token, state)
    |   |-- register(email, password)
    |   |-- login(email, password)
    |   |-- updateApiKey(token, apiKey)
    |
    |-- [chat.js]
    |   |-- sendMessage(chatWindowNumber)
    |   |-- saveCurrentChat(chatWindowNumber)
    |   |-- startNewChat(chatWindowNumber)
    |   |-- loadSavedChatHistory(chatWindowNumber, historyIndex)
    |   |-- loadAndDisplayChatHistory(chatWindowNumber)
    |   |-- addAssistantRadioButtons(chatWindowNumber)
    |   |-- restoreRadioButtons(chatWindowNumber)
    |   |-- saveWindow(windowNumber)
    |   |-- initializeNewChatWindow(windowNumber)
    |
    |-- [chatEntryPoint.js]
    |   |-- Event listeners and initialization for the chat page
    |
    |-- [localStorage.js]
    |   |-- loadTranscriptsFromLocalStorage()
    |
    |-- [loginEntryPoint.js]
    |   |-- Event listeners and initialization for the login page
    |
    |
    |-- [registerEntryPoint.js]
    |   |-- Event listeners and initialization for the registration page
    |
    |-- [settingsEntryPoint.js]
    |   |-- Event listeners and initialization for the settings page
    |
    |-- [state.js]
    |   |-- globalState object
    |   |-- getStateValue(key)
    |   |-- setStateValue(key, value, syncWithBackend)
    |   |-- fetchAndInitializeUserState(token)
    |   |-- getUserState(token)
    |   |-- initializeGlobalStateFromBackend(userState)
    |   |-- updateBackendState()
    |   |-- loadSelectedHistoryIndexes()
    |
    |-- [style.css]
    |   |-- CSS styles for the entire chat interface
    |
    |-- [ui.js]
    |   |-- displayMessage(message, type, chatWindowNumber, isWaitingAnimation, assistantName)
    |   |-- displayConsoleMessage(consoleMessage)
    |   |-- displayTranscriptDirectory()
    |   |-- displayTranscript(index)
    |   |-- createWaitingAnimation()
    |   |-- toggleSideWindow()
    |   |-- autoExpandTextarea(event)
    |   |-- populateAssistantDropdowns(chatWindowNumber)
    |   |-- populateHistoryDropdowns()
    |   |-- populateSavedWindowsDropdown()
    |   |-- loadSavedBorderColors()
    |   |-- applySavedBorderColor(windowNumber)
    |   |-- addColorPickerEventListener(windowNumber)
    |   |-- makeTitleEditable(windowNumber)
    |   |-- saveNewTitle(windowNumber)
    |   |-- applySavedWindowTitle(windowNumber)
    |   |-- recreateSavedWindows()
    |   |-- createNewChatWindow(initialize)
    |   |-- createNewChatWindowWithSavedState(savedWindowStateIndex)
    |   |-- closeChatWindow(windowNumber)
    |   |-- changeBorderColor(color, windowNumber)
    |   |-- addEventListenersToWindow(windowNumber)
    |   |-- initializeApplicationState()
    |   |-- doDrag(e, banner, startY, startHeight)
    |   |-- stopDrag(e, doDragBound, stopDragBound)
    |   |-- initializeTextareaFocus()
    |   |-- pasteTranscriptTitle(title)
    |   |-- initializeSideWindow()
    |
    |-- [utils.js]
        |-- handleConsoleMessage(consoleMessage)
        |-- sendConsoleMessageToAssistant(consoleMessage)
        |-- displayWaitingAnimationAndDisableInput()
        |-- enableUserInput()
        |-- queueConsoleMessage(consoleMessage)
        |-- processNextConsoleMessageInQueue()
        |-- addConsoleLogMessage(message, isWaiting)
        |-- handleKeydownToSendMessage(event, chatWindowNumber)
        |-- removeSelectedAssistantRadioButton(chatWindowNumber)
        |-- loadSelectedAssistantDropdownIds()
        |-- saveDropdownStates()
        |-- loadDropdownStates()
        |-- applySavedDropdownStates()

[/REPO_MAP]




[APPLICATION_DESCRIPTION]:

The provided codebase is a Flask web application designed to interface with OpenAI's GPT models, specifically customized versions of ChatGPT for a particular use case. The application is structured to handle user interactions, manage AI agents, and facilitate complex conversations with the help of various tools and services. Below is a detailed description of the application's structure and components based on the provided repository map.

### Flask Application Setup (`main.py`)
The Flask application is initialized in `main.py`, which serves as the entry point. It performs several critical functions:
- **Version Check**: Ensures the OpenAI library version meets the required minimum.
- **Flask App Creation**: Instantiates the Flask app and sets up template and static folders.
- **Configuration Setup**: Configures the app with a secret key and database URI from environment variables.
- **Database Initialization**: Initializes SQLAlchemy with the Flask app for ORM support.
- **Route Setup**: Defines the routes for the web application by calling `setup_routes(app)`.
- **App Context and Server Start**: Creates the database tables within the application context and runs the Flask server.

### Routes (`routes.py`)
This module sets up the endpoints for the web application:
- **Home Page**: Renders the login page.
- **Chat Interface**: Renders the main chat interface after login.
- **User Registration**: Handles new user registration requests and renders the registration page.
- **Settings Page**: Renders the page where users can update their API key.
- **User Authentication**: Handles user login requests and updates API keys.
- **State Management**: Retrieves and sets the user's state, which includes their session information and chat history.
- **Chat Operations**: Handles starting new chat sessions and processing user messages through the `run` and `start` endpoints.
- **Assistant Management**: Lists available assistants for the user to interact with.

### Functions (`functions` directory)
This directory contains modules that define various chat types and tools used within the application.

#### Chat Types (`chat_types.py`)
- **Duo Interaction (`duo_i`)**: Simulates a conversation between a user proxy and a duo agent for a given number of iterations.
- **X Poll (`x_poll`)**: Orchestrates a complex conversation involving multiple specialized AI assistants and a team leader.

#### Tools (`tools.py`)
- **GIINT (`giint`)**: Invoked in response to every user message, returning a conversation transcript between a duo assistant and a user proxy.
- **Awaken Assistant (`awaken_assistant`)**: Used to initiate the conversation with an AI assistant based on the user's query domain.
- **GIINT Flow (`giint_flow`)**: Called when a user query requires attention from additional experts, running asynchronously in the background.
- **SDNA Progenitor (`SDNA_Progenitor`)**: Generates an SDNA profile for a given domain.
- **SDNA Chaining (`SDNA_Chaining`)**: Constructs chains for enhanced latent space manipulation.
- **SDNA Morph (`SDNA_Morph`)**: Morphs constructs for a given context.
- **Procreate (`procreate`)**: Generates additional instructions for agents based on the domain and context.

#### Utilities (`utils.py`)
- **Response Handling**: Functions to get single or combined responses from a list of messages.
- **Instruction Retrieval**: Functions to fetch instructions and tools for agents based on their type and domain.
- **Schema Retrieval**: Retrieves the schema for an agent type and domain.

### Services (`services` directory)
This directory contains modules that provide various services required by the application.

#### Chat Services (`chat_services.py`)
- **Rendering Pages**: Functions to render different pages of the web application.
- **Chat Handling**: Functions to handle starting new chat sessions and processing user messages.

#### OpenAI Client Wrapper (`openai_client.py`)
- **OpenAIClientWrapper**: A wrapper class around the OpenAI API, providing methods to interact with the OpenAI services, such as creating assistants, threads, and running the assistants.

#### Models (`models.py`)
- **User**: A SQLAlchemy model representing a user, including methods for password management and state retrieval.

#### Authentication Services (`auth_services.py`)
- **Token Management**: Functions to generate and verify authentication tokens.
- **User Registration and Login**: Functions to handle user registration and login processes.

### GIINT Modules (`giint` directory)
This directory contains modules related to GIINT agents and threads.

#### GIINT Agent (`giint_agent.py`)
- **GiintAgent**: Represents an AI agent, capable of being awakened and serialized to JSON.

#### GIINT Thread (`giint_thread.py`)
- **GiintThread**: Manages conversation threads, including context retrieval and auxiliary agent management.

#### Factories (`giint_factories.py`)
- **GiintAgentFactory**: Factory for creating GIINT agents.
- **GiintThreadFactory**: Factory for creating GIINT threads.

#### Repositories (`giint_repositories.py`)
- **GiintAgentRepository**: Manages the persistence of GIINT agents.
- **GiintThreadRepository**: Manages the persistence of GIINT threads.

### Templates (`templates` directory)
Contains HTML templates for the web application's pages, including the login, chat interface, registration, and settings pages.

### Static Files (`static` directory)
Contains JavaScript modules, CSS styles, and entry point scripts for handling the client-side logic of the application.

#### JavaScript Modules
- **API Interactions (`api.js`)**: Functions to interact with the backend API, including fetching console messages, sending messages to the server, and managing user state.
- **Chat Logic (`chat.js`)**: Functions related to chat operations, such as sending messages, saving chat history, and managing chat windows.
- **Entry Points**: Scripts that initialize event listeners and application state for different pages (`chatEntryPoint.js`, `loginEntryPoint.js`, `registerEntryPoint.js`, `settingsEntryPoint.js`).
- **Local Storage (`localStorage.js`)**: Functions to load transcripts from local storage.
- **State Management (`state.js`)**: Manages the global state of the application, including fetching and updating user state.
- **Styling (`style.css`)**: CSS styles for the application's user interface.
- **UI Components (`ui.js`)**: Functions to manipulate the user interface, such as displaying messages and managing the side window.
- **Utility Functions (`utils.js`)**: Helper functions for console message handling, event processing, and state management.

### Files (`files` directory)
Contains JSON files defining the schema for agents (`assistant_schema.json`), existing agents (`giint_agents.json`), threads (`giint_threads.json`), instructions (`instructions.json`), and tools (`tools.json`). These files are crucial for the dynamic operation of the application, providing the necessary configurations and data for the GIINT system.

The application's architecture is modular, with clear separation of concerns, allowing for easy maintenance and scalability. Each component plays a specific role in the overall functionality, from user interaction to deep AI-driven conversations. The use of concurrent threads, dynamic tool invocation, and a comprehensive agent management system showcases the application's capability to handle complex AI operations and provide a rich user experience.

[/APPLICATION_DESCRIPTION]




[CODEBASE]:

[main.py]:

from flask import Flask
import openai
from app.routes import setup_routes
from packaging import version
import os
from app.services.models import db

required_version = version.parse("1.1.1")
current_version = version.parse(openai.__version__)
if current_version < required_version:
  raise ValueError(
      f"Error: OpenAI version {openai.__version__} is less than the required version 1.1.1"
  )
else:
  print("OpenAI version is compatible.")

# Create Flask app
app = Flask(__name__,
            template_folder='app/templates',
            static_folder='app/static')

# Set the secret key for the app from the environment variable
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get(
    'SQLALCHEMY_DATABASE_URI')  # Set your database URI

# Ensure a secret key is set, and if not, raise an exception
if not app.config['SECRET_KEY']:
  raise ValueError("No SECRET_KEY set for Flask application")

# Initialize SQLAlchemy with the Flask app
db.init_app(app)

setup_routes(app)

if __name__ == '__main__':
  with app.app_context():
    db.create_all()  
  app.run(host='0.0.0.0', port=8080)

[/main.py]

--[.app/]:

[__init__.py]:

(empty)

[/__init__.py]

[routes.py]:

from flask import request, jsonify
from .services import chat_services
from .services.auth_services import register_user, login_user, update_api_key, verify_token


def setup_routes(app):

  @app.route('/')
  def index():
    return chat_services.render_index()

  @app.route('/chat')
  def chat():
    return chat_services.render_chat()

  @app.route('/register', methods=['POST'])
  def register():
    data = request.json
    return register_user(data['email'], data['password'])

  @app.route('/register')
  def register_page():
    return chat_services.render_register()

  @app.route('/settings')
  def settings_page():
    return chat_services.render_settings()

  @app.route('/login', methods=['POST'])
  def login():
    data = request.json
    return login_user(data['email'], data['password'],
                      app.config['SECRET_KEY'])

  @app.route('/update_api_key', methods=['POST'])
  def update_key():
    token = request.headers.get('Authorization')
    user = verify_token(token, app.config['SECRET_KEY'])
    if user:
      return update_api_key(user, request.json['api_key'])
    return jsonify({"message": "Invalid token"}), 401

  @app.route('/get_user_state', methods=['GET'])
  def get_user_state():
    token = request.headers.get('Authorization').split(" ")[1]
    user = verify_token(token, app.config['SECRET_KEY'])
    if user:
      # Assuming a method get_state() that retrieves the user's state
      return jsonify(user.get_state()), 200
    return jsonify({"message": "Invalid token"}), 401

  @app.route('/set_user_state', methods=['POST'])
  def set_user_state():
    token = request.headers.get('Authorization').split(" ")[1]
    user = verify_token(token, app.config['SECRET_KEY'])
    if user:
      # Assuming a method set_state(data) that sets the user's state
      user.set_state(request.json)
      return jsonify({"message": "User state updated successfully"}), 200
    return jsonify({"message": "Invalid token"}), 401

  @app.route('/run', methods=['POST'])
  def run():
    data = request.json
    return chat_services.handle_run(data, app.config)

  @app.route('/start', methods=['POST'])
  def start():
    data = request.json
    return chat_services.handle_start(data, app.config)

  @app.route('/list-assistants', methods=['POST'])
  def list_assistants():
    data = request.json
    return chat_services.handle_list_assistants(data, app.config)

[/routes.py]

----[.functions/]:

[__init__.py]:

(empty)

[/__init__.py]

[chat_types.py]: 
 
import os
from concurrent.futures import ThreadPoolExecutor
from ..services import openai_client
from ..functions import utils
from ..giint.giint_service import GiintService
from ..giint.giint_factories import GiintAgentFactory, GiintThreadFactory
from ..giint.giint_repositories import GiintAgentRepository, GiintThreadRepository



#duo using a single thread and 'chat manager' system messages as user messages
def duo_i(initial_input, agent_1, agent_2, giint_thread, max_iterations=20):
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  thread_id = giint_thread.tool_thread_id
  transcript = []
  input_message = initial_input
  assistant_2_name = client.get_assistant(agent_2.assistant_id).name

  # Append the initial user input to the transcript
  user_message_init = "User Actual: " + initial_input
  transcript.append(user_message_init)
  
  if thread_id is None:
    thread_id = client.create_thread()

  for i in range(max_iterations):
    # Determine the assistant and message for the current iteration
    if i % 2 == 0:  # Even iterations (0, 2, 4, ...) - User Proxy's turn
      assistant_id = agent_1.assistant_id
      message = f"Adopt role of: 'User Proxy' and respond to last message from '{assistant_2_name}' given context." if i > 0 else f"Generate initial prompt for assistant name: '{assistant_2_name}', according to input User Query: {input_message}, and considering any and all previous conversation context when relevant. If the User Query is obviously domain specific, then use function tool 'awaken_assistant'"
      message_anno = "User Proxy: "
    else:  # Odd iterations (1, 3, 5, ...) - Assistant 2's turn
      assistant_id = giint_service.agent_repo.find_by_id(
          client, giint_thread.tool_agent_id).assistant_id
      assistant_2_name = client.get_assistant(assistant_id).name
      message = f"Last assistant message is from 'User Proxy'. Adopt role of: '{assistant_2_name}' and respond to last message given context."
      message_anno = f"{assistant_2_name}: "

    # Generate the response
    print(f'about to execute run OK')
    context = giint_thread.get_context(giint_thread.main_thread_id)
    response = client.exec_run(thread_id=thread_id,
                               messages=message,
                               assistant_id=assistant_id,
                               giint_thread=giint_thread,
                               context=context)
    combined_response = utils.get_combined_response(response)
    single_response = utils.get_single_response(response)

    # Format and append the response to the transcript
    formatted_response = f"{message_anno} {combined_response}"
    transcript.append(formatted_response)

    if isinstance(single_response,
                  str) and i % 2 == 0 and ("PASS!" in single_response
                                           or "FAIL!" in single_response):
      break

  print(f'Final trasncript from duo_i: {transcript}')
  return transcript




def x_poll(assistant_ids, team_leader_id, initial_input, giint_thread):
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)
  
  # create run_xp tool in tools.py that calls THIS function, generates and feeds in agent ids etc...
  # change parameters to accept 'agents' instead of plain assistant ids for assistant_list and team_leader_id
  # use 
  
  transcript = [f"User Actual: {initial_input}"]
  assistant_names = [
      client.get_assistant(assistant_id).name for assistant_id in assistant_ids
  ]
  assistant_name_list = ', '.join(
      f"{index + 1}. {name}" for index, name in enumerate(assistant_names))

  # Start thread_prime with team leader
  thread_prime = client.create_thread()
  team_leader_name, _ = client.get_assistant(team_leader_id)
  team_leader_message = f"SYSTEM NOTICE!!!\nMERGE_INSTRUCTIONS = '{team_leader_name}' + 'TEAM LEADER'\n\n[TEAM LEADER INSTRUCTIONS]:\nYou are the 'TEAM LEADER', charged with orchestrating a conversation topology that involves multiple specialized AI assistants. Your pivotal role encompasses receiving, evaluating, and responding to attempts these assistants make at providing a reply to the 'User's query'. Such a query may take the form of a question, task, goal, objective, or other similar type. Each assistant is selected for their proficiency in a specific domain relevant to the User's query, and your job is to guide this collective intelligence towards delivering a coordinated and comprehensive response that caters to the User's needs.\n\nHere's an overview of your refined structure of duties:\n\nSTEP 1:\nInitial Query Reception: Upon receipt of the User's query, your prime objective is to analyze and reinterpret the query adding necessary context where deemed beneficial. The resultant output—a composite prompt—will be disseminated to a team of multiple specialized assistants, each chosen for their unique capabilities tailored to the query's subject matter.\n\nSTEP 2:\nEvaluation and Feedback: Following the prompt delivery, you will receive individual responses from the team of specialized assistants. These responses, distinctly marked to preserve their origin, must be carefully evaluated to understand their approach and effectiveness. Your next task is to synthesize the findings from the initial responses. This synthesis should capture the essence of each assistant's contribution and outline specific areas needing improvement. This collective analysis, accompanied by the synthesis, will be dispatched sequentially to the specialized assistants for refinement. As the feedback loop progresses, each specialized assistant will act iteratively, receiving not only your synthesis and feedback but also the improved responses from preceding assistants. This sequential structure cultivates a collaborative improvement process, ultimately leading to a more cohesive and well-rounded output by leveraging the strengths of all assistants.\n\nSTEP 3:\nFinal Evaluation and Synthesis: Upon the completion of the second reinforcement round, a consolidated transcript comprising the newly refined responses from each assistant will revert to your oversight. It is your responsibility to appraise these closing remarks, confirm the conclusions drawn by the specialists, and articulate a verbose summarization that encapsulates the successful aspects of the conversation chain.\n[/TEAM LEADER INSTRUCTIONS]\n\n\n\n---\nSYSTEM COMMAND!!!\nROLE = TEAM LEADER: '{team_leader_name}'\n\nFollow instructions for STEP 1.\n\n[STEP 1]:\nInitial Query Reception: Upon receipt of the User's query, your prime objective is to analyze and reinterpret the query adding necessary context where deemed beneficial. The resultant output—a composite prompt—will be disseminated to a team of three specialized assistants, each chosen for their unique capabilities tailored to the query's subject matter.\n[/STEP 1]\n\nIMPORTANT!!! DO NOT REFER TO THE STEP NUMBER IN YOUR MESSAGE TO THE ASSISTANTS!!!\n\n---\nSpecialized Assistants:\n\n'{assistant_name_list}'\n\n---\n\nUser's Query = '{initial_input}'"
  transcript.append(f"SYSTEM: {team_leader_message}")
  response = client.exec_run(thread_prime, team_leader_message, team_leader_id)
  transcript.append(f"{team_leader_name}: {response}")
  response_init = f"SYSTEM COMMAND!!!\nROLE = '{assistant_name_list}'\n\nYou are working with a group of other Assistants to solve a problem together, and your work is being planned, coordinated, managed, and delivered by another Assistant reffered to as: TEAM LEADER: '{team_leader_name}'. Based on your own system instructions, generate a complete reply to the relevant part of the Team Leader's prompt below.\n\n\n\n---\n\nTEAM LEADER PROMPT: '{response}'"
  transcript.append(f"ALT_THREAD_SYSTEM: {response_init}")
  # Create and run threads for each assistant in parallel
  with ThreadPoolExecutor() as executor:
    futures = []
    for assistant_id in assistant_ids:
      assistant_object = client.get_assistant(assistant_id)
      assistant_name = assistant_object.name
      if isinstance(assistant_name, str):
        system_message = response_init.replace("{assistant_name_list}",
                                               assistant_name)
      else:
        assistant_name_default = "Untitled Assistant"
        system_message = response_init.replace("{assistant_name_list}",
                                               assistant_name_default)

      futures.append(
          executor.submit(
              client.thread_and_run,
              assistant_id,
              system_message,
          ))
    responses = [future.result() for future in futures]

  # Prepend names to responses and append to transcript individually
  for name, resp in zip(assistant_names, responses):
    transcript.append(f"ALT_THREAD_{name}: {resp}")

  # Combine responses and run on thread_prime
  combined_responses = '\n\n'.join(
      f"{name}: {resp}" for name, resp in zip(assistant_names, responses))
  combined_responses_init = f"SYSTEM COMMAND!!!\nROLE = TEAM LEADER: '{team_leader_name}'\n\nFollow instructions for STEP 2.\n\n[STEP 2]:\n\nEvaluation and Feedback: Following the prompt delivery, you will receive the combined individual responses from the set of specialized assistants. These responses, distinctly marked to preserve their origin, must be carefully evaluated to understand their approach and effectiveness. Your next task is to synthesize the findings from the initial responses. This synthesis should capture the essence of each assistant's contribution and outline specific areas needing improvement. This collective analysis, accompanied by the synthesis, will be dispatched sequentially to the specialized assistants for refinement. As the feedback loop progresses, each specialized assistant will act iteratively, receiving not only your synthesis and feedback but also the improved responses from preceding assistants. This sequential structure cultivates a collaborative improvement process, ultimately leading to a more cohesive and well-rounded output by leveraging the strengths of all assistants.\n\n[/STEP 2]\n\n---\n\nCombined Responses:\n\n{combined_responses}"
  transcript.append(f"SYSTEM: {combined_responses_init}")
  response = client.exec_run(thread_prime, combined_responses_init,
                             team_leader_id)
  transcript.append(f"{team_leader_name}: {response}")

  # Iterate through assistants and run on thread_prime
  for assistant_id, assistant_name in zip(assistant_ids, assistant_names):
    last_assistant_name = team_leader_name if assistant_id == assistant_ids[
        0] else assistant_names[assistant_ids.index(assistant_id) - 1]
    role_adopt_message = f"SYSTEM COMMAND!!!\nROLE_CHANGE = '{assistant_name}'\n\nLast assistant message is from '{last_assistant_name}'. Continue work based on last message and prior context."
    transcript.append(f"SYSTEM: {role_adopt_message}")
    response = client.exec_run(thread_prime, role_adopt_message, assistant_id)
    transcript.append(f"{assistant_name}: {response}")

  # Final run with team leader
  final_message = "SYSTEM COMMAND!!!\nROLE_CHANGE = TEAM LEADER: '{team_leader_name}'\n\nFollow instructions for STEP 3 based on all prior context.\n\n[STEP 3]:\nFinal Evaluation and Synthesis: Upon the completion of the second reinforcement round, a consolidated transcript comprising the newly refined responses from each assistant will revert to your oversight. It is your responsibility to appraise these closing remarks, confirm the conclusions drawn by the specialists, and articulate a verbose summarization that encapsulates the successful aspects of the conversation chain.\n[/STEP 3]"
  transcript.append(f"SYSTEM: {final_message}")
  response = client.exec_run(thread_prime, final_message, team_leader_id)
  transcript.append(f"{team_leader_name}: {response}")

  return transcript
 
[/chat_types.py] 
 
 
[tools.py]: 
 
import os
import json
from ..services import openai_client
from . import chat_types
from ..giint.giint_service import GiintService
from ..giint.giint_factories import GiintAgentFactory, GiintThreadFactory
from ..giint.giint_repositories import GiintAgentRepository, GiintThreadRepository
from . import utils


def giint(arguments, context, giint_thread):
  new_message = context[-1]
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  # Create and save the user proxy agent
  user_proxy_agent = giint_service.agent_factory.create_agent(
      client=client, agent_type='user_proxy_agent', domain='default')
  giint_service.agent_repo.save(user_proxy_agent)

  duo_agent = giint_service.agent_factory.create_agent(client=client,
                                                       agent_type='duo_agent',
                                                       domain='default')
  giint_service.agent_repo.save(duo_agent)
  giint_thread.tool_agent_id = duo_agent.agent_id
  giint_service.thread_repo.save(giint_thread)

  # Use the chat_types module to simulate the conversation between the user proxy and the duo agent
  transcript = chat_types.duo_i(initial_input=new_message,
                                agent_1=user_proxy_agent,
                                agent_2=duo_agent,
                                giint_thread=giint_thread,
                                max_iterations=10)
  formatted_transcript = utils.get_combined_response(transcript)
  print(f'Final trasncript from giint tool: {transcript}')
  return formatted_transcript


def awaken_assistant(arguments, context, giint_thread):
  print("awaken_assistant_called!")
  print(f"{arguments}")
  new_message = context[-1]
  arg_de_string = json.loads(arguments)
  print(f"arg_de_string: {arg_de_string}")
  domain = arg_de_string.get('domain', 'default')
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  additional_instructions = procreate(domain=domain,
                                      context=new_message,
                                      giint_thread=giint_thread)

  new_duo_agent = giint_service.agent_factory.create_agent(
      client=client,
      domain=domain,
      agent_type='duo_agent',
      additional_instructions=additional_instructions)
  giint_service.agent_repo.save(new_duo_agent)
  giint_thread.tool_agent_id = new_duo_agent.agent_id
  giint_service.thread_repo.save(giint_thread)

  return f"A new agent has been created for the domain: {domain}, and replaced as the tool agent on the giint_thread."


def giint_flow(arguments, context, giint_thread):
  new_message = context[-2] + '\n\n' + context[-1]
  domain = arguments.get('domain', 'default')
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  additional_instructions = procreate(domain=domain,
                                      context=new_message,
                                      giint_thread=giint_thread)

  new_agent = giint_service.agent_factory.create_agent(
      client=client,
      domain=domain,
      agent_type='progeny_agent',
      additional_instructions=additional_instructions)
  giint_service.agent_repo.save(new_agent)

  giint_thread.add_auxiliary_agent(new_agent.agent_id)
  giint_service.thread_repo.save(giint_thread)

  return f"A new agent has been created for the domain: {domain}"


def SDNA_Progenitor(arguments, context, giint_thread):
  input_text = f"{arguments}.\n\n---\n\nConsidering the context:\n\n'{context}'"
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  progenitor_agent = giint_service.agent_factory.create_agent(
      client=client, agent_type='progenitor_agent')
  assistant_id = progenitor_agent.assistant_id

  try:
    thread_id = client.create_thread().id
    response = client.exec_run(thread_id,
                               input_text,
                               assistant_id=assistant_id)
    client.delete_assistant(assistant_id)
    return response

  except Exception as e:
    print(f"Error calling the SDNA_Progenitor: {e}")
    return {"error": str(e)}


def SDNA_Chaining(arguments, context, giint_thread):
  input_text = f"{arguments}.\n\n---\n\nConsidering the context:\n\n'{context}'"
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  chaining_agent = giint_service.agent_factory.create_agent(
      client=client, agent_type='chaining_agent')
  assistant_id = chaining_agent.assistant_id

  try:
    thread_id = client.create_thread().id
    response = client.exec_run(thread_id,
                               input_text,
                               assistant_id=assistant_id)
    client.delete_assistant(assistant_id)
    return response
  except Exception as e:
    print(f"Error calling the SDNA_Morph: {e}")
    return {"error": str(e)}


# Function to call the SDNA_Morph
def SDNA_Morph(arguments, context, giint_thread):
  input_text = f"{arguments}.\n\n---\n\nConsidering the context:\n\n'{context}'"
  client = giint_thread.client
  agent_factory = GiintAgentFactory()
  thread_factory = GiintThreadFactory()
  agent_repo = GiintAgentRepository()
  thread_repo = GiintThreadRepository()
  giint_service = GiintService(client, agent_factory, thread_factory,
                               agent_repo, thread_repo)

  morph_agent = giint_service.agent_factory.create_agent(
      client=client, agent_type='morph_agent')
  assistant_id = morph_agent.assistant_id

  try:
    thread_id = client.create_thread().id
    response = client.exec_run(thread_id,
                               input_text,
                               assistant_id=assistant_id)
    client.delete_assistant(assistant_id)
    return response
  except Exception as e:
    print(f"Error calling the SDNA_Morph: {e}")
    return {"error": str(e)}


def procreate(domain, context, giint_thread):
  arguments = {
      "input_text": f"Generate an SDNA profile for the domain: {domain}"
  }
  profile = SDNA_Progenitor(arguments=arguments,
                            context=context,
                            giint_thread=giint_thread)
  arguments = {"input_text": f"Generate SDNA Chains for the domain: {domain}"}
  chains = SDNA_Chaining(arguments=arguments,
                         context=profile,
                         giint_thread=giint_thread)
  composite = f"{profile}\n\n{chains}"
  arguments = {
      "input_text": f"Generate an SDNA Morph Block for the domain: {domain}"
  }
  morph_block = SDNA_Morph(arguments=arguments,
                           context=composite,
                           giint_thread=giint_thread)
  new_instructions = f"{composite}\n\n{morph_block}"
  return new_instructions
 
[/tools.py] 
 
 
[utils.py]: 
 
import json



def get_single_response(response):
  if isinstance(response, list) and response:
    return response[-1]
  elif isinstance(response, str):
    return response
  else:
    return None


def get_combined_response(response):
  if isinstance(response, list):
    return '\n\n\n'.join(response)
  elif isinstance(response, str):
    return response
  else:
    return None



def get_instructions(instruction_names, additional_instructions=None):
  instructions_file = 'app/files/instructions.json'
  additional_instructions_placeholder = "<ADDITIONAL_INSTRUCTIONS>"
  with open(instructions_file, 'r') as file:
    instructions_data = json.load(file)
  instructions = []
  for name in instruction_names:
    if name == additional_instructions_placeholder and additional_instructions is not None:
      instructions.append(additional_instructions)
    else:
      instructions.append(instructions_data.get(name, ""))
  return "\n\n".join(instructions)


def get_tools(tool_names):
  tools_file = 'app/files/tools.json'
  with open(tools_file, 'r') as file:
    tools_data = json.load(file)
  tools = [tools_data[name] for name in tool_names if name in tools_data]
  return tools


def get_schema(agent_type, domain):
  schema_file = 'app/files/assistant_schema.json'
  with open(schema_file, 'r') as file:
    schemas = json.load(file)
  schema = schemas.get(agent_type)
  if not schema:
    raise ValueError(f"No schema found for agent_type: {agent_type}")
  if domain != "default" and domain in schema:
    return schema[domain]
  return schema["default"]
 
[/utils.py]

----[/.functions/]


----[.services/]:

[__init__.py]:

(empty)

[/__init__.py]

[chat_services.py]: 
 
from ..functions.chat_types import x_poll, duo_i
from flask import request, render_template, jsonify
from .openai_client import OpenAIClientWrapper
from ..giint.giint_service import GiintService
from ..giint.giint_factories import GiintAgentFactory, GiintThreadFactory
from ..giint.giint_repositories import GiintAgentRepository, GiintThreadRepository
from .auth_services import verify_token
from .models import db


def render_index():
  return render_template('index.html')


def render_chat():
  return render_template('chat.html')


def render_register():
  return render_template('register.html')


def render_settings():
  return render_template('settings.html')


def handle_start(data, config):
  token = request.headers.get('Authorization').split(" ")[1]
  user = verify_token(token, config['SECRET_KEY'])
  if user and user.api_key:
    # Use the user's API key and state for the GiintService
    client = OpenAIClientWrapper(user.api_key)
    agent_factory = GiintAgentFactory()
    thread_factory = GiintThreadFactory()
    agent_repo = GiintAgentRepository()
    thread_repo = GiintThreadRepository()

    # Create the GiintService with all dependencies
    giint_service = GiintService(client, agent_factory, thread_factory,
                                 agent_repo, thread_repo)

    # Use the service to start a new giint session by calling run_giint with no giint_id and new_message
    giint_id = giint_service.run_giint(new_message=None, giint_id=None)

    # Return the giint_id to the frontend
    return jsonify({'giint_id': giint_id})

  return jsonify({'error': 'Invalid token or API key'}), 401


def handle_run(data, config):
  token = request.headers.get('Authorization').split(" ")[1]
  user = verify_token(token, config['SECRET_KEY'])
  if user and user.api_key:
    giint_id = data.get('giint_id')
    user_input = data.get('message', '')
    assistant_id = data.get('assistant_id')

    # Instantiate the dependencies
    client = OpenAIClientWrapper(user.api_key)
    agent_factory = GiintAgentFactory()
    thread_factory = GiintThreadFactory()
    agent_repo = GiintAgentRepository()
    thread_repo = GiintThreadRepository()

    # Create the GiintService with all dependencies
    giint_service = GiintService(client, agent_factory, thread_factory,
                                 agent_repo, thread_repo)

    # Use the service to run giint logic
    messages_list = giint_service.run_giint(new_message=user_input,
                                            giint_id=giint_id,
                                            assistant_id=assistant_id)

    if not messages_list:
      return None

    assistant_messages = []
    for message in messages_list.data:
      if message.role == 'assistant':
        assistant_messages.append(message)
      elif message.role == 'user':
        break  # Stop once a user message is encountered

    # Process the collected assistant messages
    responses = []
    for msg in assistant_messages:
      if hasattr(msg.content[0], 'text'):
        responses.append(msg.content[0].text.value)
      elif hasattr(msg.content[0], 'image_file'):
        responses.append(msg.content[0].image_file.file_id)
      else:
        # Handle other content types here
        responses.append(
            f"Unknown content type: {type(msg.content[0]).__name__}")

    # Return the collected responses in the order they were sent (oldest first)
    flipped_responses = responses[::-1]
    print(
        f'The actual message getting returned to user is: {flipped_responses}')

    formatted_response = {
        "message": {
            "type": "string",
            "value": flipped_responses
        }
    }
    return jsonify(formatted_response)


def handle_list_assistants(data, config):
  token = request.headers.get('Authorization').split(" ")[1]
  user = verify_token(token, config['SECRET_KEY'])
  if user and user.api_key:
    # Use the user's API key for the OpenAI client
    client = OpenAIClientWrapper(api_key=user.api_key)

    try:
      # Fetch the list of assistants
      assistant_list = client.get_assistant_list()
      assistants_data = assistant_list['data']

      # Format the response
      formatted_response = {
          "assistants": [{
              'id': asst.id,
              'name': asst.name
          } for asst in assistants_data]
      }

      return jsonify(formatted_response)
    except Exception as e:
      # Handle exceptions
      return jsonify({'error': str(e)}), 500
 
[/chat_services.py] 
 
 
[openai_client.py]: 
 
from openai import OpenAI
import time
from ..functions import tools


class OpenAIClientWrapper:

  def __init__(self, api_key):
    self.client = OpenAI(api_key=api_key)

  def create_file(self, file_path, purpose):
    with open(file_path, "rb") as file:
      file_object = self.client.files.create(file=file, purpose=purpose)
      return file_object

  def create_assistant(self,
                       model,
                       name=None,
                       description=None,
                       instructions=None,
                       tools=None,
                       file_paths=None,
                       metadata=None):
    body = {"model": model}
    if name is not None:
      body["name"] = name
    if description is not None:
      body["description"] = description
    if instructions is not None:
      body["instructions"] = instructions
    if tools is not None:
      body["tools"] = tools
    if file_paths is not None:
      file_ids = [
          self.create_file(file_path, 'assistants').id
          for file_path in file_paths
      ]
      body["file_ids"] = file_ids
    if metadata is not None:
      body["metadata"] = metadata

    print(f"Creating assistant with name: {name}")

    # Make the API call to create the assistant
    assistant_object = self.client.beta.assistants.create(**body)
    return assistant_object

  def delete_assistant(self, assistant_id):
    response = self.client.beta.assistants.delete(assistant_id)
    return response

  def add_assistant_file(self, assistant_id, file_id):
    assistant_file_object = self.client.beta.assistants.files.create(
        assistant_id=assistant_id, file_id=file_id)
    return assistant_file_object

  def get_assistant(self, assistant_id):
    assistant_object = self.client.beta.assistants.retrieve(assistant_id)
    return assistant_object

  def get_assistant_list(self, limit=100, order='desc'):
    all_assistants = []
    params = {"limit": limit, "order": order}

    # Loop to handle pagination
    while True:
      # Make the API call to list the assistants
      response = self.client.beta.assistants.list(**params)
      all_assistants.extend(
          response.data)  # Add the current page of assistants to the list

      # Check if there are more assistants to fetch
      if response.has_more:
        # Update the 'after' parameter to the last assistant's ID to get the next page
        params['after'] = response.data[-1].id
      else:
        break  # Exit the loop if there are no more assistants to fetch

    return {
        "data": all_assistants,
        "has_more":
        False  # Since we've collected all data, there's no more pagination
    }

  def create_thread(self):
    thread_object = self.client.beta.threads.create()
    return thread_object

  def add_messages(self, thread_id, messages):
    message_objects = []
    print(f"adding message: {messages}")
    # Send a message to the specified conversation thread
    if not isinstance(messages, list):
      messages = [messages]

    for message in messages:
      message_object = self.client.beta.threads.messages.create(
          thread_id=thread_id, role="user", content=message)
      message_objects.append(message_object)
    print(f'added messages: {message_objects}')
    return message_objects

  def get_message_list(self, thread_id):
    # Get the list of messages in the specified conversation thread
    message_list = self.client.beta.threads.messages.list(thread_id=thread_id)
    return message_list

  def get_message(self, thread_id, message_id):
    # Get the message with the specified ID from the specified conversation thread
    message_object = self.client.beta.threads.messages.retrieve(
        thread_id=thread_id, message_id=message_id)
    return message_object

  def create_run(self, thread_id, assistant_id):
    # Run the assistant for the specified conversation thread
    print(
        f"i am now in the create_run function with thread_id: {thread_id} and assistant_id: {assistant_id}"
    )
    run_object = self.client.beta.threads.runs.create(
        thread_id=thread_id, assistant_id=assistant_id)
    print("succesfully made run with openai client")
    return run_object

  def get_run(self, thread_id, run_id):
    # Get the details of a specific run
    run_object = self.client.beta.threads.runs.retrieve(thread_id=thread_id,
                                                        run_id=run_id)
    return run_object

  def submit_tool_outputs(self, thread_id, run_id, tool_outputs):
    # Submit the tool outputs for a specific run
    response = self.client.beta.threads.runs.submit_tool_outputs(
        thread_id=thread_id, run_id=run_id, tool_outputs=tool_outputs)
    return response

  def exec_run(self,
               thread_id,
               messages,
               assistant_id,
               context=None,
               giint_thread=None):

    self.add_messages(thread_id, messages)
    # Add the user's message to the thread and run the Assistant
    print(f"okay really starting the run now")
    run_object = self.create_run(thread_id, assistant_id)

    # Check if the Run requires action (function call)
    while True:
      run_status = self.get_run(thread_id, run_object.id)
      if run_status.status == 'completed':
        break
      elif run_status.status == 'requires_action':
        # Check if 'required_action' is not None and 'submit_tool_outputs' is present
        required_action = getattr(run_status, 'required_action', None)
        if required_action and hasattr(required_action, 'submit_tool_outputs'):
          tool_calls = required_action.submit_tool_outputs.tool_calls
          tool_outputs = []
          for tool_call in tool_calls:
            func_name = tool_call.function.name
            arguments = tool_call.function.arguments
            print(f"arguments: {arguments}")
            # Dynamically get the function from the tools module
            func = getattr(tools, func_name, None)
            if func:
              # Call the function dynamically
              output = func(arguments, context, giint_thread)
              tool_outputs.append({
                  "tool_call_id": tool_call.id,
                  "output": output
              })
            else:
              # Handle the case where the function doesn't exist
              print(f"Function {func_name} not found in tools module.")

          self.submit_tool_outputs(thread_id, run_object.id, tool_outputs)
        else:
          # Handle the case where 'submit_tool_outputs' is not present or 'required_action' is None
          print("No tool outputs to submit or required_action is None.")
          break  # or continue, depending on the desired behavior
      time.sleep(1)  # Wait for a second before checking again

    messages_list = self.get_message_list(thread_id)
    print(f"Messages list: {messages_list}")
    if not messages_list:
      return None  # or some default value indicating no messages

    # Collect all consecutive assistant messages starting from the latest
    assistant_messages = []
    for message in messages_list.data:
      if message.role == 'assistant':
        assistant_messages.append(message)
      elif message.role == 'user':
        break  # Stop once a user message is encountered

    # Process the collected assistant messages
    responses = []
    for msg in assistant_messages:
      if hasattr(msg.content[0], 'text'):
        responses.append(msg.content[0].text.value)
      elif hasattr(msg.content[0], 'image_file'):
        responses.append(msg.content[0].image_file.file_id)
      else:
        # Handle other content types here
        responses.append(
            f"Unknown content type: {type(msg.content[0]).__name__}")

    # Return the collected responses in the order they were sent (oldest first)
    return responses[::
                     -1]  # Reverse the list to get the correct chronological order

  def thread_and_run(self, assistant_id, system_message):
    thread_id = self.create_thread()
    response = self.exec_run(thread_id, system_message, assistant_id)
    return response
 
[/openai_client.py] 
 
 
[models.py]: 
 
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash

db = SQLAlchemy()


class User(db.Model):
  id = db.Column(db.Integer, primary_key=True)
  email = db.Column(db.String(120), unique=True, nullable=False)
  password_hash = db.Column(db.String(128))
  api_key = db.Column(db.String(128))
  state = db.Column(db.JSON)

  def set_password(self, password):
    self.password_hash = generate_password_hash(password)

  def check_password(self, password):
    return check_password_hash(self.password_hash, password)

  def get_state(self):
    return self.state or {}

  def set_state(self, state_data):
    self.state = state_data
    db.session.commit()
 
[/models.py] 
 
 
[auth_services.py]: 
 
from .models import User, db
from flask import jsonify
from itsdangerous import URLSafeTimedSerializer as Serializer


# Assuming app secret key is set in the Flask app config
def generate_token(email, secret_key, expiration=3600):
  s = Serializer(secret_key)
  return s.dumps({'email': email}), expiration


def verify_token(token, secret_key):
  s = Serializer(secret_key)
  try:
    email = s.loads(token)['email']
  except:
    return None
  return User.query.filter_by(email=email).first()


def register_user(email, password):
  user = User(email=email)
  user.set_password(password)
  db.session.add(user)
  db.session.commit()
  return jsonify({"message": "User registered successfully"}), 201


def login_user(email, password, secret_key):
  user = User.query.filter_by(email=email).first()
  if user and user.check_password(password):
    token, expiration = generate_token(user.email, secret_key)
    return jsonify({"token": token, "expiration": expiration}), 200
  return jsonify({"message": "Invalid credentials"}), 401


def update_api_key(user, api_key):
  user.api_key = api_key
  db.session.commit()
  return jsonify({"message": "API key updated successfully"}), 200
 
[/auth_services.py]

----[/.services/]


----[.giint/]:

[__init__.py]:

(empty)

[/__init__.py]

[giint_agent.py]: 
 
import uuid
from ..services import openai_client
from ..functions import utils


class GiintAgent:

  def __init__(self,
               client,
               agent_id=None,
               domain=None,
               agent_type=None,
               assistant_id=None,
               additional_instructions=None):
    self.agent_id = agent_id or str(uuid.uuid4())
    self.domain = domain
    self.agent_type = agent_type
    self.client = client
    self.additional_instructions = additional_instructions
    self.assistant_id = assistant_id if assistant_id is not None else self.awaken(
    )

  def awaken(self, agent_type=None, domain=None, additional_instructions=None):
    agent_type = agent_type or self.agent_type
    domain = domain or self.domain
    domain_name = f": {domain}" if domain != "default" else " "
    additional_instructions = additional_instructions or self.additional_instructions
    assistant_schema = utils.get_schema(agent_type=agent_type, domain=domain)
    instruction_names = assistant_schema['instruction_names']
    instructions = utils.get_instructions(instruction_names,
                                          additional_instructions)
    tools = utils.get_tools(assistant_schema['tool_names'])
    return self.client.create_assistant(
        model=assistant_schema['model'],
        name=assistant_schema['name'] + domain_name,
        description=assistant_schema['description'],
        instructions=instructions,
        tools=tools,
        file_paths=assistant_schema['file_paths'],
        metadata=assistant_schema['metadata']).id

  def to_json(self):
    return {
        'agent_id': self.agent_id,
        'assistant_id': self.assistant_id,
        'domain': self.domain,
        'agent_type': self.agent_type
    }

  @staticmethod
  def from_json(client, data):
    return GiintAgent(client=client,
                      agent_id=data['agent_id'],
                      assistant_id=data['assistant_id'],
                      domain=data['domain'],
                      agent_type=data['agent_type'])
 
[/giint_agent.py] 
 
 
[giint_thread.py]: 
 
import uuid
from ..services import openai_client


class GiintThread:

  def __init__(self,
               client,
               giint_id=None,
               main_agent_id=None,
               main_thread_id=None):
    self.giint_id = giint_id or str(uuid.uuid4())
    self.client = client
    self.main_agent_id = main_agent_id
    self.main_thread_id = main_thread_id if main_thread_id is not None else self.client.create_thread(
    ).id
    self.tool_agent_id = None
    self.tool_thread_id = self.client.create_thread().id
    self.auxiliary_agents_threads = {
    }  # Dictionary to store auxiliary agent IDs and their corresponding thread IDs

  def get_context(self, thread_id):
    all_messages = self.client.get_message_list(thread_id)
    if not all_messages:
      return None

    responses = []
    for msg in all_messages.data:
      if hasattr(msg.content[0], 'text'):
        responses.append(msg.content[0].text.value)
      elif hasattr(msg.content[0], 'image_file'):
        responses.append(msg.content[0].image_file.file_id)
      else:
        # Handle other content types here
        responses.append(
            f"Unknown content type: {type(msg.content[0]).__name__}")
    return responses[::-1]

  def add_auxiliary_agent_thread(self, auxiliary_agent_id):
    auxiliary_thread_id = self.client.create_thread().id
    self.auxiliary_agents_threads[auxiliary_agent_id] = auxiliary_thread_id

  def remove_auxiliary_agent_thread(self, auxiliary_agent_id):
    if auxiliary_agent_id in self.auxiliary_agents_threads:
      del self.auxiliary_agents_threads[auxiliary_agent_id]

  def to_json(self):
    return {
        'giint_id': self.giint_id,
        'main_agent_id': self.main_agent_id,
        'main_thread_id': self.main_thread_id,
        'tool_agent_id': self.tool_agent_id,
        'tool_thread_id': self.tool_thread_id,
        'auxiliary_agents_threads': self.auxiliary_agents_threads
    }

  @staticmethod
  def from_json(client, data):
    thread = GiintThread(client=client,
                         giint_id=data['giint_id'],
                         main_agent_id=data['main_agent_id'],
                         main_thread_id=data['main_thread_id'])
    thread.tool_agent_id = data.get('tool_agent_id')
    thread.tool_thread_id = data.get('tool_thread_id')
    thread.auxiliary_agents_threads = data.get('auxiliary_agents_threads', {})
    return thread
 
[/giint_thread.py] 
 
 
[giint_factories.py]: 
 
from .giint_agent import GiintAgent
from .giint_thread import GiintThread


class GiintAgentFactory:

  def create_agent(self,
                   client,
                   domain=None,
                   agent_type=None,
                   assistant_id=None,
                   additional_instructions=None):
    # Logic to create and return a GiintAgent instance
    print(
        f"Creating GiintAgent with API key: {client}, domain: {domain}, agent_type: {agent_type}, assistant_id: {assistant_id}"
    )
    return GiintAgent(client=client,
                      agent_type=agent_type,
                      domain=domain,
                      assistant_id=assistant_id,
                      additional_instructions=additional_instructions)


class GiintThreadFactory:

  def create_thread(self, client, main_agent_id=None):
    # Logic to create and return a GiintThread instance
    return GiintThread(client=client, main_agent_id=main_agent_id)
 
[/giint_factories.py] 
 
 
[giint_repositories.py]: 
 
import json
import os
from .giint_agent import GiintAgent
from .giint_thread import GiintThread

GIINT_AGENTS_FILE = 'app/files/giint_agents.json'
GIINT_THREADS_FILE = 'app/files/giint_threads.json'


class GiintAgentRepository:

  def save(self, agent):
    # Save agent to storage
    agents = self.load_agents()
    agents[agent.agent_id] = agent.to_json()
    with open(GIINT_AGENTS_FILE, 'w') as file:
      json.dump(agents, file, indent=4)

  def find_by_id(self, client, agent_id):
    # Retrieve agent from storage
    agents = self.load_agents()
    agent_data = agents.get(agent_id)
    return GiintAgent.from_json(client, agent_data) if agent_data else None

  def load_agents(self):
    if os.path.exists(GIINT_AGENTS_FILE):
      with open(GIINT_AGENTS_FILE, 'r') as file:
        return json.load(file)
    return {}


class GiintThreadRepository:

  def save(self, thread):
    # Save thread to storage
    threads = self.load_threads()
    threads[thread.giint_id] = thread.to_json()
    with open(GIINT_THREADS_FILE, 'w') as file:
      json.dump(threads, file, indent=4)

  def find_by_id(self, client, thread_id):
    # Retrieve thread from storage
    threads = self.load_threads()
    thread_data = threads.get(thread_id)
    return GiintThread.from_json(client, thread_data) if thread_data else None

  def load_threads(self):
    if os.path.exists(GIINT_THREADS_FILE):
      with open(GIINT_THREADS_FILE, 'r') as file:
        return json.load(file)
    return {}
 
[/giint_repositories.py] 
 
 
[giint_service.py]: 
 
import time
from ..functions import tools


class GiintService:

  def __init__(self, client, agent_factory, thread_factory, agent_repo,
               thread_repo):
    self.client = client
    self.agent_factory = agent_factory
    self.thread_factory = thread_factory
    self.agent_repo = agent_repo
    self.thread_repo = thread_repo

  def run_giint(self, new_message=None, giint_id=None, assistant_id=None):
    # Retrieve or create a GiintThread
    if giint_id:
      giint_thread = self.thread_repo.find_by_id(self.client, giint_id)
      if not giint_thread:
        raise ValueError("Thread not found")
    else:
      giint_thread = self.thread_factory.create_thread(client=self.client)
      self.thread_repo.save(giint_thread)
      return giint_thread.giint_id

    # Check if the thread has a main agent, create one if not
    if not giint_thread.main_agent_id:
      main_agent = self.agent_factory.create_agent(client=self.client,
                                                   agent_type="main_agent",
                                                   domain="default",
                                                   assistant_id=assistant_id)
      self.agent_repo.save(main_agent)
      giint_thread.main_agent_id = main_agent.agent_id
      self.thread_repo.save(giint_thread)
    else:
      main_agent = self.agent_repo.find_by_id(self.client,
                                              giint_thread.main_agent_id)
      if assistant_id is not None:
        # if assistant id given, swap out on main agent (should actually be re-awakened by pulling assisant data, and then making a new main agent with additional instructions and additional tools given from the provided assistant)
        main_agent.assistant_id = assistant_id
      else:
        # main_agent found on thread, BUT no assistant_id given in request, then reset main_agent to default
        main_agent = self.agent_factory.create_agent(client=self.client,
                                                     agent_type="main_agent",
                                                     domain="default")
        self.agent_repo.save(main_agent)
        giint_thread.main_agent_id = main_agent.agent_id
        self.thread_repo.save(giint_thread)

    # Add message to thread and run the agent
    self.client.add_messages(giint_thread.main_thread_id, new_message)
    context = giint_thread.get_context(giint_thread.main_thread_id)
    run_object = self.client.create_run(giint_thread.main_thread_id,
                                        main_agent.assistant_id)
    while True:
      run_status = self.client.get_run(giint_thread.main_thread_id,
                                       run_object.id)
      if run_status.status == 'completed':
        break
      elif run_status.status == 'requires_action':
        print('tool was called')
        required_action = getattr(run_status, 'required_action', None)
        if required_action and hasattr(required_action, 'submit_tool_outputs'):
          tool_calls = required_action.submit_tool_outputs.tool_calls
          print(f'Tool calls: {tool_calls}')
          tool_outputs = []
          for tool_call in tool_calls:
            func_name = tool_call.function.name
            arguments = tool_call.function.arguments
            # Dynamically get the function from the tools module
            func = getattr(tools, func_name, None)
            if func:
              # Call the function dynamically
              output = func(arguments, context, giint_thread)
              tool_outputs.append({
                  "tool_call_id": tool_call.id,
                  "output": output
              })
            else:
              # Handle the case where the function doesn't exist
              print(f"Function {func_name} not found in tools module.")
          print(f'Tool outputs: {tool_outputs}')
          self.client.submit_tool_outputs(giint_thread.main_thread_id,
                                          run_object.id, tool_outputs)

        else:
          print("No tool outputs to submit or required_action is None.")
          break
        time.sleep(1)

    messages_list = self.client.get_message_list(giint_thread.main_thread_id)
    return messages_list
 
[/giint_service.py]

----[/.giint/]


----[.templates/]:

[index.html]: 
 
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Login</title>
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" type="text/css" />
</head>

<body>

  <div class="top-banner">
  </div>
  <div class="login-container">
    <!-- Email Input -->
    <div class="email-input-container">
      <label for="email-input">Email Address:</label>
      <input type="email" id="email-input" placeholder="Enter your email here">
    </div>

    <!-- Password Input -->
    <div class="password-container">
      <label for="password-input">Password:</label>
      <input type="password" id="password-input" placeholder="Enter your password here">
    </div>

    <!-- Submit Button -->
    <button id="login-submit" disabled>Submit</button>
    <button id="go-to-register" class="nav-button">Register</button>
  </div>

  <script type="module" src="{{ url_for('static', filename='loginEntryPoint.js') }}"></script>
</body>

</html> 
[/index.html] 
 
 
[chat.html]: 
 
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat Interface</title>
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" type="text/css" />
</head>

<body>
  <div class="top-banner" id="draggable-banner">
    <!-- ASCII art for the logo "onion_morph" -->
    <pre id="ascii-logo" class="ascii-art">
       ________  ___  ___  ________   _________   
      |\   ____\|\  \|\  \|\   ___  \|\___   ___\ 
      \ \  \___|\ \  \ \  \ \  \\ \  \|___ \  \_| 
       \ \  \  __\ \  \ \  \ \  \\ \  \   \ \  \  
        \ \  \|\  \ \  \ \  \ \  \\ \  \   \ \  \ 
         \ \_______\ \__\ \__\ \__\\ \__\   \ \__\
          \|_______|\|__|\|__|\|__| \|__|    \|__|
    </pre>
    <!-- Console log area -->
    <div class="console-log" id="console-log">
      <!-- Console messages will be added here -->
    </div>
    <!-- Add a handle to drag and resize the banner -->
    <div class="resize-handle"></div>
  </div>
  <!-- Main content container -->
  <div class="main-content">
    <!-- Chat Window (Progeny) -->
    <div class="chat-window" id="chat-window-1">
      <header class="chat-header">
        <select class="history-dropdown" id="history-dropdown-1">
          <option value="">Select a history...</option>
        </select>
        <h1 class="chat-title" id="chat-title-1">Progeny</h1>
        <button class="save-window-button" id="save-window-button-1">Save Window</button>
      </header>
      <div class="chat-container" id="chat-container-1"></div>
      <div class="chat-input-container">
        <div class="message-row">
          <button class="new-chat-button" id="new-chat-button-1">New Chat</button>
          <textarea class="message-input" id="message-input-1" placeholder="Type a message..."></textarea>
          <button class="send-button" id="send-button-1">Send</button>
        </div>
        <div class="assistant-controls">
          <button class="remove-assistant-button" id="remove-assistant-button-1">Remove</button>
          <select class="assistant-dropdown" id="assistant-dropdown-1"></select>
          <button class="add-assistant-button" id="add-assistant-button-1">Add</button>
        </div>
        <div id="radio-buttons-container-1">
          <input type="radio" id="radio-none-1" name="assistant-radio-1" value="" class="assistant-radio" checked>
          <label for="radio-none-1">None</label>
        </div>
        <input type="color" class="color-swatch" id="color-swatch-1" title="Change border color">
      </div>
    </div>

    <!-- Additional chat windows would be inserted here -->

    <button id="new-window-button">New Window</button>
    <button id="go-to-settings" class="nav-button">Settings</button>
    <select id="saved-windows-dropdown">
      <option value="">Select a saved window...</option>
    </select>
  </div>

  <!-- Side Window -->
  <div class="side-window" id="side-window">
    <button class="collapse-button" id="collapse-button">Collapse</button>
    <div class="transcript-directory" id="transcript-directory"></div>
    <div class="transcript-display" id="transcript-display">
      <button class="back-button" id="back-button">Back</button>
      <div class="transcript-messages" id="transcript-messages"></div>
    </div>
  </div>

  <!-- Expand Button (visible when side window is collapsed) -->
  <button class="expand-button" id="expand-button">Expand</button>

  <script type="module" src="{{ url_for('static', filename='chatEntryPoint.js') }}"></script>
</body>

</html> 
[/chat.html] 
 
 
[register.html]: 
 
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Register</title>
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" type="text/css" />
</head>
<body>
  <div class="register-container">
    <div class="email-container">
      <label for="register-email-input">Email:</label>
      <input type="email" id="register-email-input" placeholder="Enter your email here">
    </div>
    <div class="password-container">
      <label for="register-password-input">Password:</label>
      <input type="password" id="register-password-input" placeholder="Create a password">
    </div>
    <button id="register-submit">Register</button>
  </div>
  <script type="module" src="{{ url_for('static', filename='registerEntryPoint.js') }}"></script>
</body>
</html> 
[/register.html] 
 
 
[settings.html]: 
 
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Account Settings</title>
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" type="text/css" />
</head>
<body>
  <div class="settings-container">
    <div class="api-key-container">
      <label for="api-key-input">API Key:</label>
      <input type="text" id="api-key-input" placeholder="Enter your OpenAI API Key here">
    </div>
    <button id="update-api-key">Update API Key</button>
  </div>
  <script type="module" src="{{ url_for('static', filename='settingsEntryPoint.js') }}"></script>
</body>
</html> 
[/settings.html]

----[/.templates/]


----[.static/]:

[api.js]: 
 
import {populateHistoryDropdowns, displayTranscriptDirectory, toggleSideWindow, displayConsoleMessage, displayMessage} from './ui.js';
import {saveCurrentChat} from './chat.js';
import {enableUserInput, handleConsoleMessage, addConsoleLogMessage, processNextConsoleMessageInQueue} from './utils.js';
import { getStateValue, setStateValue } from './state.js';
import { globalState } from './state.js';



function fetchConsoleMessages() {
    const token = sessionStorage.getItem('token'); // Retrieve the session token
    console.log('Fetching console messages...');
    fetch('https://sdnarivet-evanswesleya.replit.app/fetch-transcripts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}` // Include the session token in the request headers
      },
    body: JSON.stringify({
      filePath: "ASSPRIME.rivet-project",
      graph: "PRIME/GET_DUO_TRANSCRIPT",
      inputs: {
        ...(apiKey ? { "apiKey": apiKey } : {}),
        ...(email ? { "email": email } : {})
      }
    })
  })
  .then(response => response.json())
  .then(data => {
    console.log('Response data:', data); // Log the response data
    // Check if transcripts are present and the array is not empty
    if (data.transcripts && data.transcripts.type === "any[]" && Array.isArray(data.transcripts.value) && data.transcripts.value.length > 0) {
      console.log('Processing console messages:', data.transcripts.value); // Log the transcripts value
      // Combine all strings into one message with a delimiter
      const consoleMessage = 'CONSOLE MESSAGE:\n' + data.transcripts.value.join('\n------\n');

      console.log('Console message to handle:', consoleMessage); // Log the formatted console message
      // Handle the console message
      handleConsoleMessage(consoleMessage);
    } else {
      console.log('No new console messages found.'); // Log when no new messages are found
    }
  })
  .catch(error => {
    console.error('Error fetching console messages:', error);
  });
}


function sendToServer(message, chatWindowNumber, isConsoleMessage = false) {
    setStateValue('isMessagePending', true);
    const startTime = Date.now();
    console.log(`Sending message to server from window ${chatWindowNumber}:`, message);

    // Retrieve the giint_id from globalState
    const giintId = getStateValue('sessionIds')[chatWindowNumber - 1];
    const token = sessionStorage.getItem('token'); // Retrieve the session token

    // Retrieve the selected assistantId from the active radio button
    const selectedRadio = document.querySelector(`input[name="assistant-radio-${chatWindowNumber}"]:checked`);
    let assistantId = selectedRadio ? selectedRadio.value : undefined;

    // If "None" is selected, fall back to the assistantId from the dropdown
    if (!assistantId) {
        assistantId = document.getElementById(`assistant-dropdown-${chatWindowNumber}`).value || undefined;
    }

    // Create request body
    const requestBody = {
        message: message,
        giint_id: giintId,
        ...(assistantId ? { assistant_id: assistantId } : {})
    };

    console.log(`Request body for window ${chatWindowNumber}:`, requestBody);

    addConsoleLogMessage(`Sending message from window ${chatWindowNumber}: ${message}`, true);

    fetch('https://onion-morph.replit.app/run', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}` // Include the session token in the request headers
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => response.json())
    .then(data => {
        const reply = data.message.value[0];
        addConsoleLogMessage(`Received response for window ${chatWindowNumber}: ${reply}`);

        if (reply) {
            // Update the chat history in globalState
            const chatHistories = getStateValue('chatHistories');
            const chatHistory = chatHistories[chatWindowNumber - 1];
            chatHistory.push({ message: message, type: isConsoleMessage ? 'console-message' : 'sent' });
            chatHistory.push({ message: reply, type: 'received' });
            setStateValue('chatHistories', chatHistories, true);

            if (isConsoleMessage) {
                displayConsoleMessage(message);
                setTimeout(() => {
                    const assistantNameForReply = getStateValue('newIdArray').find(assistant => assistant.id === assistantId)?.name;
                    displayMessage(reply, 'received', chatWindowNumber, false, assistantNameForReply ? assistantNameForReply + ":" : null);
                    enableUserInput();
                    processNextConsoleMessageInQueue();
                }, 2000);
            } else {
                const assistantName = getStateValue('newIdArray').find(assistant => assistant.id === assistantId)?.name;
                displayMessage(reply, 'received', chatWindowNumber, false, assistantName ? assistantName + ":" : null);
            }
        }

        setStateValue('isMessagePending', false);

        // Remove waiting animation after receiving the response
        const waitingDotsContainer = document.querySelector(`#chat-container-${chatWindowNumber} .waiting-dots-container`);
        if (waitingDotsContainer) {
            waitingDotsContainer.remove();
        }

        if (data.new_id && data.new_id.type === "any[]" && data.new_id.value) {
          refreshAssistantList(); // Call refreshAssistantList function to refresh the list
        }

        const endTime = Date.now();
        console.log(`Response received and processed in ${endTime - startTime}ms for window ${chatWindowNumber}`);
    })
    .catch(error => {
        console.error(`Error sending message from window ${chatWindowNumber}:`, error);
        displayMessage('Error', 'received', chatWindowNumber);
        setStateValue('isMessagePending', false);
    });
}



function refreshAssistantList() {
    const token = sessionStorage.getItem('token'); // Retrieve the session token

    fetch('https://onion-morph.replit.app/list-assistants', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}` // Include the session token in the request headers
      }
    })
    .then(response => response.json())
    .then(data => {
      // Update the newIdArray in globalState
      setStateValue('newIdArray', data.assistants, true);
      console.log('Assistant pairs received and stored:', data.assistants);
    })
    .catch(error => {
      console.error('Error fetching assistant pairs:', error);
    });
}


function fetchTranscripts() {
    const token = sessionStorage.getItem('token'); // Retrieve the session token
    const isViewingTranscript = document.getElementById('transcript-display').style.display === 'block';

    fetch('https://sdnarivet-evanswesleya.replit.app/fetch-transcripts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        filePath: "ASSPRIME.rivet-project",
        graph: "PRIME/GET_XP_TRANSCRIPT",
        inputs: {}
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.transcripts && data.transcripts.type === "any[]" && Array.isArray(data.transcripts.value)) {
        data.transcripts.value.forEach(transcriptArray => {
          if (Array.isArray(transcriptArray)) {
            const title = transcriptArray.pop().replace(/\r\n/g, '<br>');
            sendTitleToBackend(title, token); // Updated to include token
            const newTranscript = {
              title: title,
              messages: transcriptArray.map(message => message.replace(/\r\n/g, '<br>'))
            };
            const transcripts = getStateValue('transcripts');
            transcripts.push(newTranscript);
            setStateValue('transcripts', transcripts, true); // Sync with backend
          }
        });

        if (!isViewingTranscript) {
          displayTranscriptDirectory();
          const sideWindow = document.getElementById('side-window');
          if (sideWindow.style.right === '-25%' && data.transcripts.value.length > 0) {
            toggleSideWindow();
          }
        }
      }
    })
    .catch(error => {
      console.error('Error fetching new transcripts:', error);
    });
}


// Function to send the transcript title to the backend
function sendTitleToBackend(title) {
  const token = sessionStorage.getItem('token'); // Retrieve the session token

  const formattedTitle = title.replace(/<br>/g, '\n');
  fetch('https://sdnarivet-evanswesleya.replit.app/append-transcript-title', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}` // Include the session token in the request headers
    },
    body: JSON.stringify({ email: email, title: formattedTitle })
  })
  .then(response => response.json())
  .then(data => {
    console.log('Transcript title appended to Google Sheet:', data.message);
  })
  .catch(error => {
    console.error('Error appending transcript title to Google Sheet:', error);
  });
}


async function getUserState(token) {
    const response = await fetch('/get_user_state', {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });
    if (response.ok) {
        return response.json();
    } else {
        throw new Error('Failed to retrieve user state.');
    }
}

async function setUserState(token, state) {
    const response = await fetch('/set_user_state', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(state)
    });
    if (!response.ok) {
        throw new Error('Failed to save user state.');
    }
}

async function register(email, password) {
    try {
        const response = await fetch('/register', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email: email, password: password })
        });
        if (response.ok) {
            alert('Registration successful. Please log in.');
            window.location.href = '/'; // Redirect to login page
        } else {
            const data = await response.json();
            throw new Error(data.message || 'Failed to register');
        }
    } catch (error) {
        console.error('Error during registration:', error);
        alert(error.message);
    }
}


async function login(email, password) {
    try {
        const response = await fetch('/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email: email, password: password })
        });
        const data = await response.json();
        if (response.ok && data.token) {
            sessionStorage.setItem('token', data.token);
            window.location.href = '/chat';
        } else {
            throw new Error('Failed to log in');
        }
    } catch (error) {
        console.error('Error during login:', error);
        alert('Failed to log in. Please check the console for more information.');
    }
}


async function updateApiKey(token, apiKey) {
    try {
        const response = await fetch('/update_api_key', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ api_key: apiKey })
        });
        if (response.ok) {
            alert('API key updated successfully.');
        } else {
            const data = await response.json();
            throw new Error(data.message || 'Failed to update API key.');
        }
    } catch (error) {
        console.error('Error updating API key:', error);
        alert(error.message);
    }
}




export { fetchConsoleMessages, sendToServer, refreshAssistantList, fetchTranscripts, sendTitleToBackend, login, register, getUserState, setUserState, updateApiKey }; 
[/api.js] 
 
 
[chat.js]: 
 
import {populateAssistantDropdowns, populateSavedWindowsDropdown, displayMessage, populateHistoryDropdowns} from './ui.js';
import {sendToServer} from './api.js';
import { getStateValue, setStateValue, initializeGlobalStateFromBackend } from './state.js';
import { globalState } from './state.js';



function sendMessage(chatWindowNumber) {
    const userEmail = getStateValue('userEmailForSheets'); // Use getStateValue instead of localStorage
    if (!userEmail) {
        alert('Please submit your email before sending a message.');
        return;
    }

    const inputField = document.getElementById(`message-input-${chatWindowNumber}`);
    const message = inputField.value.trim();
    if (message) {
        displayMessage(message, 'sent', chatWindowNumber);
        const chatHistories = getStateValue('chatHistories');
        chatHistories[chatWindowNumber - 1].push({ message, type: 'sent' });
        setStateValue('chatHistories', chatHistories, true); // Sync with backend
        console.log(`Updated chat history after sending for window ${chatWindowNumber}:`, chatHistories[chatWindowNumber - 1]);
        inputField.value = '';

        displayMessage('', 'received', chatWindowNumber, true); // Show waiting animation
        sendToServer(message, chatWindowNumber); // sendToServer function should also be updated to use the token
    }
}


 
function saveCurrentChat(chatWindowNumber) {
  const currentHistory = getStateValue('chatHistories')[chatWindowNumber - 1];
  const currentGiintId = getStateValue('sessionIds')[chatWindowNumber - 1];
  let historyName = new Date().toISOString();

  let targetArray = getStateValue('savedChatHistories');
  const existingHistoryIndex = targetArray.findIndex(history => history.giintId === currentGiintId);

  if (existingHistoryIndex !== -1) {
    targetArray[existingHistoryIndex].history = currentHistory.slice();
    setStateValue('selectedHistoryIndexes', {
      ...getStateValue('selectedHistoryIndexes'),
      [chatWindowNumber]: existingHistoryIndex
    }, true);
  } else {
    const savedHistory = {
      name: historyName,
      history: currentHistory.slice(),
      giintId: currentGiintId
    };
    targetArray.push(savedHistory);
    setStateValue('selectedHistoryIndexes', {
      ...getStateValue('selectedHistoryIndexes'),
      [chatWindowNumber]: targetArray.length - 1
    }, true);
  }

  setStateValue('savedChatHistories', targetArray, true);
}


function startNewChat(chatWindowNumber) {
  // Clear the chat history for the given window number
  const chatHistories = getStateValue('chatHistories');
  chatHistories[chatWindowNumber - 1] = [];
  setStateValue('chatHistories', chatHistories, true);
  document.getElementById(`chat-container-${chatWindowNumber}`).innerHTML = '';

  const token = sessionStorage.getItem('token'); // Retrieve the session token

  fetch('https://onion-morph.replit.app/start', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}` // Include the session token in the request headers
    }
  })
  .then(response => response.json())
  .then(data => {
    if (data.giint_id) {
      // Update the globalState with the new giint_id
      const sessionIds = getStateValue('sessionIds');
      sessionIds[chatWindowNumber - 1] = data.giint_id;
      setStateValue('sessionIds', sessionIds, true);
      console.log(`New giint_id received and stored for window ${chatWindowNumber}:`, data.giint_id);
    } else {
      console.error('Failed to get a new giint_id from the backend.');
    }
  })
  .catch(error => {
    console.error('Error starting a new chat:', error);
  });

  // Reset the selected history index for this window
  const selectedHistoryIndexes = getStateValue('selectedHistoryIndexes');
  selectedHistoryIndexes[chatWindowNumber] = undefined;
  setStateValue('selectedHistoryIndexes', selectedHistoryIndexes, true);

  // Populate the history dropdowns to reflect the reset state
  populateHistoryDropdowns();
}


async function loadSavedChatHistory(chatWindowNumber, historyIndex) {
  const token = sessionStorage.getItem('token'); // Retrieve the session token
  const savedChatHistories = getStateValue('savedChatHistories');
  const savedHistory = savedChatHistories[historyIndex];

  if (savedHistory) {
    document.getElementById(`chat-container-${chatWindowNumber}`).innerHTML = '';
    const chatHistories = getStateValue('chatHistories');
    chatHistories[chatWindowNumber - 1] = savedHistory.history.slice();
    setStateValue('chatHistories', chatHistories); // Update globalState

    const sessionIds = getStateValue('sessionIds');
    sessionIds[chatWindowNumber - 1] = savedHistory.giintId;
    setStateValue('sessionIds', sessionIds); // Update globalState

    // Load and display the chat history for the window
    loadAndDisplayChatHistory(chatWindowNumber);
  }
}


async function loadAndDisplayChatHistory(chatWindowNumber) {
  const chatContainer = document.getElementById(`chat-container-${chatWindowNumber}`);
  chatContainer.innerHTML = ''; // Clear the chat container before loading history

  const chatHistories = getStateValue('chatHistories');
  const chatHistory = chatHistories[chatWindowNumber - 1];

  if (!chatHistory || chatHistory.length === 0) {
    console.log(`No chat history found for window ${chatWindowNumber}`);
    return;
  }

  console.log(`Loaded chat history for window ${chatWindowNumber}:`, chatHistory);
  chatHistory.forEach(item => displayMessage(item.message, item.type, chatWindowNumber));
}


function addAssistantRadioButtons(chatWindowNumber) {
  const assistantDropdown = document.getElementById(`assistant-dropdown-${chatWindowNumber}`);
  const selectedAssistantId = assistantDropdown.value;
  const selectedAssistantName = assistantDropdown.options[assistantDropdown.selectedIndex].text;

  if (!selectedAssistantId) {
    alert('Please select an assistant to add.');
    return;
  }

  const radioButtonsContainer = document.getElementById(`radio-buttons-container-${chatWindowNumber}`);
  const radioInput = document.createElement('input');
  radioInput.type = 'radio';
  radioInput.id = `radio-${selectedAssistantId}-${chatWindowNumber}`;
  radioInput.name = `assistant-radio-${chatWindowNumber}`;
  radioInput.value = selectedAssistantId;
  radioInput.classList.add('assistant-radio');

  const radioLabel = document.createElement('label');
  radioLabel.htmlFor = radioInput.id;
  radioLabel.textContent = selectedAssistantName;

  radioButtonsContainer.appendChild(radioInput);
  radioButtonsContainer.appendChild(radioLabel);

  // Update the radio button state in globalState
  const radioState = {
    id: selectedAssistantId,
    name: selectedAssistantName,
    selected: radioInput.checked
  };
  let radioStates = getStateValue('radioStates')[chatWindowNumber] || [];
  radioStates.push(radioState);
  setStateValue('radioStates', { ...getStateValue('radioStates'), [chatWindowNumber]: radioStates }, true);
}

function restoreRadioButtons(chatWindowNumber) {
  const radioStates = getStateValue('radioStates')[chatWindowNumber] || [];
  const radioButtonsContainer = document.getElementById(`radio-buttons-container-${chatWindowNumber}`);
  const noneRadioInput = document.getElementById(`radio-none-${chatWindowNumber}`);

  noneRadioInput.checked = true; // Initially set "None" radio button to checked

  // Remove all dynamically created radio buttons
  radioButtonsContainer.querySelectorAll('.assistant-radio:not(#radio-none-' + chatWindowNumber + ')').forEach(radio => radio.parentNode.removeChild(radio));

  // Restore the radio buttons from the saved state, excluding the "None" button
  radioStates.forEach(radioState => {
    if (radioState.id !== "") {
      const radioInput = document.createElement('input');
      radioInput.type = 'radio';
      radioInput.id = `radio-${radioState.id}-${chatWindowNumber}`;
      radioInput.name = `assistant-radio-${chatWindowNumber}`;
      radioInput.value = radioState.id;
      radioInput.classList.add('assistant-radio');
      radioInput.checked = radioState.selected;

      const radioLabel = document.createElement('label');
      radioLabel.htmlFor = radioInput.id;
      radioLabel.textContent = radioState.name;

      radioButtonsContainer.appendChild(radioInput);
      radioButtonsContainer.appendChild(radioLabel);

      if (radioState.selected) {
        noneRadioInput.checked = false;
      }
    }
  });
}


function saveWindow(windowNumber) {
  const title = document.getElementById(`chat-title-${windowNumber}`).textContent;
  const borderColor = getStateValue(`borderColor-${windowNumber}`);
  const radioStates = getStateValue(`radioStates-${windowNumber}`) || [];

  const windowState = {
    title,
    borderColor,
    radioStates,
    windowNumber
  };

  // Update the savedWindowStates in globalState and sync with backend
  const savedWindowStates = getStateValue('savedWindowStates');
  savedWindowStates.push(windowState);
  setStateValue('savedWindowStates', savedWindowStates, true);

  populateSavedWindowsDropdown();
}


function initializeNewChatWindow(windowNumber) {
  // Check if a giintId is already stored, if not, request a new one
  let giintId = getStateValue(`giintId-${windowNumber}`);
  if (!giintId) {
    // If there's no giintId, start a new chat to get one
    startNewChat(windowNumber);
  } else {
    // If a giintId is found, use it and load the chat history
    const chatHistories = getStateValue('chatHistories');
    chatHistories[windowNumber - 1] = giintId;
    setStateValue('chatHistories', chatHistories);

    loadAndDisplayChatHistory(windowNumber);
  }

  // Restore radio buttons for this chat window
  restoreRadioButtons(windowNumber);

  populateAssistantDropdowns();
  populateHistoryDropdowns();
}


export { sendMessage, saveCurrentChat, startNewChat, loadSavedChatHistory, loadAndDisplayChatHistory, addAssistantRadioButtons, restoreRadioButtons, saveWindow, initializeNewChatWindow }; 
[/chat.js] 
 
 
[chatEntryPoint.js]: 
 
import {addEventListenersToWindow, initializeSideWindow, initializeApplicationState, initializeTextareaFocus, doDrag, stopDrag, createNewChatWindow, createNewChatWindowWithSavedState, applySavedWindowTitle} from './ui.js';
import {loadTranscriptsFromLocalStorage} from './localStorage.js';
import {addConsoleLogMessage, processNextConsoleMessageInQueue} from './utils.js';
import {fetchConsoleMessages} from './api.js';
import { globalState } from './state.js';
import { fetchAndInitializeUserState, updateBackendState } from './state.js';
import { setStateValue, getStateValue } from './state.js';


setInterval(fetchConsoleMessages, 10000);


// Event listeners and initialization specific to the chat page
document.addEventListener('DOMContentLoaded', async function () {
  const banner = document.getElementById('draggable-banner');
  const consoleLog = document.getElementById('console-log');
  const mainContent = document.querySelector('.main-content');
  const minHeight = 90; // The default minimum height of the banner

  // Fetch and initialize user state from the backend
  const token = sessionStorage.getItem('token');
  if (token) {
    await fetchAndInitializeUserState(token);
  }

  // Capture the initial height of the console log area
  globalState.consoleLogInitialHeight = consoleLog.clientHeight;

  if (banner) {
    let startY, startHeight;

    // Attach the mousedown event listener to the entire banner
    banner.addEventListener('mousedown', function (e) {
      // Only start dragging if the click is within the default height range
      if (e.offsetY <= minHeight) {
        startY = e.clientY;
        startHeight = parseInt(document.defaultView.getComputedStyle(banner).height, 10);

        // Bind the doDrag function with the necessary parameters
        const doDragBound = function (e) {
          doDrag(e, banner, startY, startHeight);
        };
        // Bind the stopDrag function with the necessary parameters
        const stopDragBound = function (e) {
          stopDrag(e, doDragBound, stopDragBound);
        };
        document.documentElement.addEventListener('mousemove', doDragBound, false);
        document.documentElement.addEventListener('mouseup', stopDragBound, false);
        document.body.classList.add('noselect'); // Disable text selection during drag
      }
    });
  }

  // Auto-collapse the banner when interacting with the lower half of the page
  mainContent.addEventListener('click', function () {
    banner.style.height = `${minHeight}px`; // Collapse to default height
    mainContent.style.paddingTop = `${minHeight}px`;
    consoleLog.style.height = `${globalState.consoleLogInitialHeight}px`; // Reset console log height
    consoleLog.scrollTop = consoleLog.scrollHeight; // Scroll to the bottom
  });

  const sideWindow = document.getElementById('side-window');
  sideWindow.style.right = '-25%'; // Set the initial state to match the CSS

  initializeApplicationState();
  initializeSideWindow();

  // Load transcripts from local storage
  loadTranscriptsFromLocalStorage();

  // Initialize textarea focus tracking
  initializeTextareaFocus();

  // Start fetching console messages at regular intervals
  setInterval(() => fetchConsoleMessages(token), 10000);

  // Add event listeners for the first chat window
  addEventListenersToWindow(1);

  // Apply saved window titles for the first window
  applySavedWindowTitle(1);

  // Add event listener for creating new chat windows
  document.getElementById('new-window-button').addEventListener('click', createNewChatWindow);

  const savedWindowsDropdown = document.getElementById('saved-windows-dropdown');
  savedWindowsDropdown.addEventListener('change', function() {
    const savedWindowStateIndex = this.value;
    if (savedWindowStateIndex) {
      createNewChatWindowWithSavedState(savedWindowStateIndex);
    }
  });

  processNextConsoleMessageInQueue();

  // Add the welcome message to the console log
  addConsoleLogMessage('Welcome to GIINT!');
  
  // New event listener for the "Settings" button
  const goToSettingsButton = document.getElementById('go-to-settings');
  goToSettingsButton.addEventListener('click', function() {
    window.location.href = '/settings'; // Navigate to the settings page
  });
});


window.addEventListener('beforeunload', function () {
  // Update the backend state with the number of open windows and their states
  const openWindowsCount = document.querySelectorAll('.chat-window').length;
  setStateValue('openWindowsCount', openWindowsCount, true);

  // Save the radio states for all windows
  document.querySelectorAll('.chat-window').forEach((chatWindow, index) => {
    const windowNumber = index + 1;
    const radioButtons = document.querySelectorAll(`input[name="assistant-radio-${windowNumber}"]:not(#radio-none-${windowNumber})`);
    const radioStates = Array.from(radioButtons).map(radio => ({
      id: radio.value,
      name: radio.nextSibling.textContent
    }));
    setStateValue(`radioStates-${windowNumber}`, radioStates, true);
  });

  // Synchronize the global state with the backend
  updateBackendState();
}); 
[/chatEntryPoint.js] 
 
 
[localStorage.js]: 
 
import {displayTranscriptDirectory} from './ui.js';
import { setStateValue, getStateValue } from './state.js';
import { globalState } from './state.js';

function loadTranscriptsFromLocalStorage() {
  // Assuming transcripts are already loaded into globalState at session start
  const savedTranscripts = getStateValue('transcripts');
  if (savedTranscripts && savedTranscripts.length > 0) {
    // If transcripts are already present, just update the UI
    displayTranscriptDirectory();
  } else {
    // If there are no transcripts, initialize with an empty array
    setStateValue('transcripts', []);
  }
}

export { loadTranscriptsFromLocalStorage }; 
[/localStorage.js] 
 
 
[loginEntryPoint.js]: 
 
import { login } from './api.js'; // Import the login function from api.js

// Event listeners and initialization specific to the login page
document.addEventListener('DOMContentLoaded', function () {
  const emailInput = document.getElementById('email-input');
  const passwordInput = document.getElementById('password-input');
  const loginSubmitButton = document.getElementById('login-submit');

  // Function to check if both fields are filled
  function checkFields() {
    if (emailInput.value.trim() && passwordInput.value.trim()) {
      loginSubmitButton.disabled = false;
    } else {
      loginSubmitButton.disabled = true;
    }
  }

  // Event listeners for input fields
  emailInput.addEventListener('input', checkFields);
  passwordInput.addEventListener('input', checkFields);

  // Event listener for the submit button
  loginSubmitButton.addEventListener('click', function() {
    const email = emailInput.value.trim();
    const password = passwordInput.value.trim();
    login(email, password); // Call the login function with email and password
  });

  // New event listener for the "Register" button
  const goToRegisterButton = document.getElementById('go-to-register');
  goToRegisterButton.addEventListener('click', function() {
    window.location.href = '/register'; // Navigate to the registration page
  });
});

 
[/loginEntryPoint.js] 
 
 
[state.js]: 
 
export let globalState = {
  // Transient state properties
  isMessagePending: false,
  lastFocusedTextarea: null,
  consoleLogInitialHeight: undefined,
  consoleMessageQueue: [],
  // Persistent state properties (initially empty and will be populated on session start)
  sessionIds: [],
  chatHistories: [],
  newIdArray: [],
  savedChatHistories: [],
  savedWindowStates: [],
  selectedHistoryIndexes: {},
  selectedAssistantDropdownIds: {},
  transcripts: [],
  radioStates: {},
  borderColors: {},
  openWindowsCount: 0
};

// Define which properties are persistent and need to be synchronized with the backend
const persistentStateProperties = [
  'sessionIds',
  'chatHistories',
  'newIdArray',
  'savedChatHistories',
  'savedWindowStates',
  'selectedHistoryIndexes',
  'selectedAssistantDropdownIds',
  'transcripts',
  'radioStates',
  'borderColors',
  'openWindowsCount',
];

// Utility function to get a state value
export function getStateValue(key) {
  return globalState[key];
}

// Utility function to set a state value and optionally synchronize with the backend
export function setStateValue(key, value, syncWithBackend = false) {
  globalState[key] = value;
  if (syncWithBackend && persistentStateProperties.includes(key)) {
    // Assume setUserState is a function that updates the state on the backend
    setUserState(sessionStorage.getItem('token'), { [key]: value }).catch(console.error);
  }
}

// This function should be called when the page loads or when the user logs in
export async function fetchAndInitializeUserState(token) {
  try {
    const userState = await getUserState(token); // Fetch the user's state from the backend
    initializeGlobalStateFromBackend(userState); // Initialize the global state with the fetched data
  } catch (error) {
    console.error('Error fetching user state:', error);
  }
}

// Add this function to state.js if not already present
export async function getUserState(token) {
  const response = await fetch('/get_user_state', {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  if (response.ok) {
    return response.json();
  } else {
    throw new Error('Failed to retrieve user state.');
  }
}

// Function to initialize the global state with data fetched from the backend
export function initializeGlobalStateFromBackend(userState) {
  Object.keys(userState).forEach(key => {
    setStateValue(key, userState[key]);
  });
}

// Function to update the entire state on the backend (e.g., before page unload)
export function updateBackendState() {
  setUserState(sessionStorage.getItem('token'), globalState).catch(console.error);
}



function loadSelectedHistoryIndexes() {
  const loadedIndexes = getStateValue('selectedHistoryIndexes');
  if (loadedIndexes) {
    setStateValue('selectedHistoryIndexes', loadedIndexes);
  } else {
    // If there are no loaded indexes, initialize with an empty object
    setStateValue('selectedHistoryIndexes', {});
  }
}



export {loadSelectedHistoryIndexes}; 
[/state.js] 
 
 
[style.css]: 
 
/* Base styles for entire chat interface */
body, html {
  margin: 0;
  padding: 0;
  font-family: 'Inter', sans-serif;
  background-color: #f7f8fa;
}

.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none; /* Safari */
  -khtml-user-select: none; /* Konqueror HTML */
  -moz-user-select: none; /* Old versions of Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
  user-select: none; /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
}

/* Additional styles for the login page */
.login-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh; /* Full height of the viewport */
}

.top-banner {
  background-color: #333;
  color: #fff;
  padding: 10px;
  overflow: hidden; /* Hide overflow during resizing */
  resize: vertical; /* Make the banner resizable vertically */
  min-height: 75px; /* Minimum height */
  max-height: 50vh; /* Maximum height as 50% of the viewport height */
  display: flex; /* Use flexbox for layout */
  flex-direction: column; /* Stack children vertically */
  align-items: center; /* Center children horizontally */
}

/* Style for navigation buttons */
.nav-button {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  display: block; /* Ensure it's a block-level element */
  margin: 10px auto; /* Center the button horizontally */
}

.console-log {
  font-family: monospace;
  white-space: pre; /* Preserve whitespace for ASCII art */
  overflow-y: auto; /* Allow vertical scrolling */
  width: 100%; /* Full width */
  text-align: center; /* Center text */
  flex-grow: 1; /* Allow the console log to grow */
}

/* Style for the resize handle */
.resize-handle {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 20px;
  height: 20px;
  background: #666;
  cursor: ns-resize; /* Cursor for vertical resize */
}

/* Ensure the ASCII art logo is centered */
#ascii-logo {
  text-align: center;
  margin: 0; /* Remove default margin */
}

.ascii-art {
  font-size: 8px; /* Adjust the font size as needed */
  line-height: 1; /* Adjust line height to control spacing between lines */
  margin: 0; /* Remove default margin */
  text-align: center; /* Center the ASCII art */
}

/* Adjust the main content padding to account for the banner */
.main-content {
  padding-top: 75px; /* Same as the default height of the banner */
}


#login-submit {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  margin-top: 20px; /* Space above the button */
}

/* API Key container styling */
.api-key-container {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 20px auto;
  max-width: 600px;
}

#api-key-input {
  flex-grow: 1;
  padding: 10px;
  margin-right: 10px;
  border: 1px solid #d2d2d2;
  border-radius: 18px;
}

#api-key-submit {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
}

/* Email Input container styling to match API Key container */
.email-input-container {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 20px auto;
  max-width: 600px;
}

#email-input {
  flex-grow: 1;
  padding: 10px;
  margin-right: 10px;
  border: 1px solid #d2d2d2;
  border-radius: 18px;
}

#email-submit {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
}

/* Add a flex container for the main content */
.main-content {
  display: flex;
  flex-direction: column;
  transition: margin-right 0.5s;
  width: 100%;
  flex-grow: 1; /* Allow the container to grow and shrink */
}

/* Chat window styling */
.chat-window {
  position: relative; /* This is needed for absolute positioning context */
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  margin: 20px auto;
  padding: 1em;
  overflow: hidden;
  width: 90%; /* Full width layout */
  max-width: 1200px; /* Maximum width of the chat window */
  border: 40px solid #000; /* Default border color */
}

/* Side window styling */
.side-window {
  position: fixed;
  top: 0;
  right: -25%; /* Start off-screen to the right */
  width: 25%;
  height: 100%;
  background-color: #f7f8fa;
  border-left: 1px solid #d2d2d2;
  overflow-y: auto;
  transition: right 0.5s; /* Smooth transition for the side window */
  z-index: 2; /* Ensure the side window is above the main content */
}

/* Style to push the main content when the side window is expanded */
.main-content-expanded {
  margin-right: 25%; /* Make space for the side window */
}

/* Ensure buttons are not stretched */
#new-window-button, #saved-windows-dropdown {
  width: auto; /* Reset width to auto */
  margin: 10px auto; /* Center the button horizontally */
}

/* Style for the transcript title */
.transcript-title {
  font-size: 0.8em; /* Adjust font size as needed */
  margin-bottom: 10px; /* Add some space below the title */
}

/* Add padding to the top of the transcript directory */
.transcript-directory {
  padding-top: 40px; /* Top padding */
  padding-right: 10px; /* Right padding */
  padding-bottom: 10px; /* Bottom padding */
  padding-left: 10px; /* Left padding */
}

.transcript-display {
  display: none; /* Initially hidden */
}

.transcript-messages {
  padding: 10px;
}

/* Style for the transcript container */
.transcript-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 5px; /* Add some space below each container */
}

/* Style for the 'Paste' button */
.paste-button {
  padding: 5px 10px;
  margin-left: 10px; /* Space between the transcript button and the paste button */
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  height: 100%; /* Make the height match the transcript button */
}

/* Collapse/Expand button styling */
.collapse-button, .expand-button {
  padding: 5px 10px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  position: absolute;
  top: 10px;
}

.collapse-button {
  right: 10px;
}

.expand-button {
  padding: 5px 10px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  position: absolute;
  top: 10px;
  right: 10px;
  /* display: block; */ /* Uncomment this line if you want to explicitly set it to block */
}

/* Back button styling */
.back-button {
  padding: 5px 10px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  position: relative;
  top: 10px;
  left: 10px;
  margin-bottom: 10px;
}

/* Chat bubble styling for transcripts */
.transcript-message {
  background-color: #007aff;
  color: white;
  padding: 5px 10px;
  border-radius: 12px;
  margin: 5px 0;
}

/* Adjust chat window 1 when side window is expanded */
.chat-window.expanded {
  width: 75%;
}

/* Style for the "Remove" button */
.remove-assistant-button {
  padding: 10px;
  background-color: #ff3b30; /* Red color for remove button */
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  margin-right: 10px; /* Space after the button */
}

/* Style for the "Save Window" button */
.save-window-button {
  padding: 10px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  margin: 10px auto; /* Center the button horizontally */
}

/* Style for editable title */
.editable {
  border: 1px dashed #007aff; /* Dashed border to indicate edit mode */
  padding: 2px; /* Padding for better visual */
  outline: none; /* Remove default outline */
  cursor: text; /* Text cursor for editing */
}

/* New chat window border style */
.new-chat-window {
  border: 40px solid #000; /* Default border color */
}

/* Scrollable chat container */
.chat-container {
  overflow-y: auto;
  padding: 0.5em;
  height: 400px;
  word-wrap: break-word;
}

/* Styling for the assistant's name */
.assistant-name {
  font-weight: bold;
  margin-bottom: 2px; /* Space between the name and the message */
  text-align: left;
  display: block;
  font-size: 0.9em; /* Make the name font size smaller */
}

/* Styling for the message group */
.message-group {
  display: flex;
  flex-direction: column;
  align-items: flex-start; /* Align items to the start of the flex container for assistant messages */
}

.message-group.sent-group {
  align-items: flex-end; /* Align items to the end of the flex container for user messages */
}

/* Style for the waiting dots container */
.waiting-dots-container {
  display: flex;
  align-items: center;
  justify-content: flex-start; /* Align to the left for bot messages */
  padding: 5px 10px; /* Same padding as other messages for consistency */
  min-height: 24px; /* Ensure the container has height even when empty */
}

/* Waiting for response animation styles */
.waiting-animation {
  display: inline-block;
  margin-left: 5px;
  font-size: 20px; /* Increase font size for larger dots */
}

.waiting-dot {
  display: inline-block;
  width: 10px; /* Increase width for larger dots */
  height: 10px; /* Increase height for larger dots */
  margin: 0 3px; /* Add space between dots */
  border-radius: 50%;
  background-color: #007aff;
  animation: waitingDots 1.5s infinite;
}

.waiting-dot:nth-child(2) {
  animation-delay: 0.2s;
}

.waiting-dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes waitingDots {
  0%, 80%, 100% {
    transform: scale(0);
  }
  40% {
    transform: scale(1);
  }
}

/* Styling for console message bubbles */
.console-message {
  background-color: #fffbe5; /* Very light yellow */
}

/* Styling for the console's name */
.console-name {
  font-weight: bold;
  margin-bottom: 2px; /* Space between the name and the message */
  text-align: left;
  display: block;
  font-size: 0.9em; /* Make the name font size smaller */
  color: #555; /* Darker text color for contrast */
}

/* Chat input container styling */
.chat-input-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 10px;
}

/* Message row styling */
.message-row {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
}


/* Message input styling */
.message-input {
  flex-grow: 2; /* Allow the input to grow more than buttons */
  min-height: 50px;
  resize: none;
  padding: 10px;
  margin: 0 10px; /* Add space on the sides */
  border: 1px solid #d2d2d2;
  border-radius: 18px;
}

/* Send and New Chat button styling */
.send-button, .new-chat-button {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  height: 50px; /* Match the height of the message input */
  flex-grow: 1; /* Allow buttons to grow but less than input */
}

/* Assistant controls styling */
.assistant-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  width: 100%;
  margin-top: 10px;
}

/* Assistant dropdown styling */
.assistant-dropdown {
  width: 50%; /* Adjust this value as needed */
  padding: 10px;
  margin: 0 10px;
  border: 1px solid #d2d2d2;
  border-radius: 18px;
  cursor: pointer;
  flex-grow: 2; /* Allow the dropdown to grow more than buttons */
}

/* Add and Remove button styling */
.add-assistant-button, .remove-assistant-button {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  height: 50px; /* Match the height of the dropdown */
  flex-grow: 1; /* Allow buttons to grow but less than dropdown */
}

/* Remove button specific color */
.remove-assistant-button {
  background-color: #ff3b30;
}

/* Radio buttons container styling */
.radio-buttons-container {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: center;
  width: 100%; /* Take full width of the container */
  margin-top: 10px;
}

/* Chat header styling */
.chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative; /* Needed for absolute positioning of children */
}

/* Chat title styling */
.chat-title {
  margin-top: 60px; /* Adjust this value as needed to clear the dropdown */
}

/* History dropdown styling */
.history-dropdown {
  padding: 10px;
  border: 1px solid #d2d2d2;
  border-radius: 18px;
  cursor: pointer;
  position: absolute;
  left: 20px;
  top: 20px; /* Adjust as needed */
}

/* Save window button styling */
.save-window-button {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  position: absolute;
  right: 50px; /* Adjust this value to create space for the close button */
  top: 10px;
}

/* Message bubble styling */
.message {
  display: inline-block;
  padding: 5px 10px;
  border-radius: 12px;
  word-break: break-word;
  margin: 5px 0;
  max-width: 60%;
}

/* Styling for sent messages */
.sent {
  background-color: #007aff;
  color: white;
  text-align: right;
}

/* Styling for received messages */
.received {
  background-color: #e5e5ea;
  color: black;
  text-align: left;
}

/* Color input (swatch) style */
.color-swatch {
  position: absolute; /* Restored from original CSS */
  bottom: 10px; /* Restored from original CSS */
  right: 10px; /* Restored from original CSS */
  width: 24px;
  height: 24px;
  border: none;
  cursor: pointer;
  -webkit-appearance: none;
  appearance: none;
  background: none;
}

/* Close button style */
.close-button {
  position: absolute;
  top: 10px;
  right: 10px; /* Position the close button in the top right corner */
  background-color: #ff3b30;
  color: white;
  border: none;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  line-height: 24px;
  text-align: center;
  cursor: pointer;
}

#new-window-button, #saved-windows-dropdown {
  padding: 10px 20px;
  background-color: #007aff;
  color: white;
  border: none;
  border-radius: 18px;
  cursor: pointer;
  display: block; /* Ensure it's a block-level element */
  margin: 10px auto; /* Center the button horizontally */
}

@media (max-width: 768px) {
  /* Responsive adjustments for smaller screens */
  .chat-window {
    width: 100%;
    max-width: none;
    margin: 0 auto;
    margin-bottom: 20px;
  }
} 
[/style.css] 
 
 
[ui.js]: 
 
import {loadSavedChatHistory, saveWindow, initializeNewChatWindow, addAssistantRadioButtons, restoreRadioButtons, startNewChat, sendMessage, loadAndDisplayChatHistory} from './chat.js';
import {loadSelectedHistoryIndexes} from './state.js';
import { setStateValue, getStateValue } from './state.js';
import { globalState } from './state.js';
import { fetchAndInitializeUserState, initializeGlobalStateFromBackend, updateBackendState, getUserState } from './state.js';
import {loadSelectedAssistantDropdownIds, applySavedDropdownStates, saveDropdownStates, removeSelectedAssistantRadioButton, handleKeydownToSendMessage, loadDropdownStates} from './utils.js';
import {fetchTranscripts} from './api.js';


function displayMessage(message, type, chatWindowNumber, isWaitingAnimation = false, assistantName = null) {
    const chatContainer = document.getElementById(`chat-container-${chatWindowNumber}`);
    const messageGroupDiv = document.createElement('div'); // Create a container for the message group
    messageGroupDiv.classList.add('message-group');

    // Add 'sent-group' class if it's a sent message
    if (type === 'sent') {
        messageGroupDiv.classList.add('sent-group');
    }

    if (type === 'received' && assistantName) {
        // If this is a received message and an assistant name is provided, create a div for it
        const nameDiv = document.createElement('div');
        nameDiv.classList.add('assistant-name');
        nameDiv.textContent = assistantName; // Use textContent for plain text to prevent HTML injection
        messageGroupDiv.appendChild(nameDiv); // Append the name div to the message group
    }

    // Create a div for the message bubble
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', type);

    if (isWaitingAnimation) {
        // If this is a waiting animation, add the waiting dots container class
        messageDiv.classList.add('waiting-dots-container');
        const waitingAnimation = createWaitingAnimation();
        messageDiv.appendChild(waitingAnimation);
    } else {
        // Replace escaped newline characters with HTML line breaks
        messageDiv.innerHTML = message.replace(/\n/g, '<br>');
    }

    messageGroupDiv.appendChild(messageDiv); // Append the message div to the message group
    chatContainer.appendChild(messageGroupDiv); // Append the message group to the chat container
    chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll to the bottom
}


function displayConsoleMessage(consoleMessage) {
  // Create a div for the console's name
  const nameDiv = document.createElement('div');
  nameDiv.classList.add('console-name');
  nameDiv.textContent = 'CONSOLE'; // Set the name to "CONSOLE"

  // Display the console message with different styling
  displayMessage(consoleMessage, 'console-message', 1, false, null);

  // Prepend the console's name to the message group
  const chatContainer = document.getElementById(`chat-container-1`);
  const lastMessageGroup = chatContainer.lastElementChild;
  if (lastMessageGroup) {
    lastMessageGroup.insertBefore(nameDiv, lastMessageGroup.firstChild);
  }
}


function displayTranscriptDirectory() {
  const directory = document.getElementById('transcript-directory');
  directory.innerHTML = ''; // Clear the directory

  const transcripts = getStateValue('transcripts') || [];

  transcripts.forEach((transcript, index) => {
    const transcriptContainer = document.createElement('div');
    transcriptContainer.classList.add('transcript-container');

    const transcriptElement = document.createElement('button');
    transcriptElement.innerHTML = transcript.title.replace(/\r\n/g, '<br>'); // Use innerHTML to render <br> tags
    transcriptElement.onclick = () => displayTranscript(index);
    transcriptContainer.appendChild(transcriptElement);

    const pasteButton = document.createElement('button');
    pasteButton.textContent = 'Paste';
    pasteButton.classList.add('paste-button');
    pasteButton.onclick = () => pasteTranscriptTitle(transcript.title);
    transcriptContainer.appendChild(pasteButton);

    directory.appendChild(transcriptContainer);
  });

  // Show the directory and hide the transcript display
  directory.style.display = 'block';
  document.getElementById('transcript-display').style.display = 'none';
}


function displayTranscript(index) {
  const transcripts = getStateValue('transcripts') || [];
  const transcript = transcripts[index];
  const transcriptMessages = document.getElementById('transcript-messages');
  transcriptMessages.innerHTML = ''; // Clear previous messages

  const titleElement = document.createElement('h2');
  titleElement.classList.add('transcript-title');
  titleElement.innerHTML = transcript.title.replace(/\r\n/g, '<br>');
  transcriptMessages.appendChild(titleElement);

  transcript.messages.forEach(message => {
    const messageElement = document.createElement('div');
    messageElement.classList.add('transcript-message');
    messageElement.innerHTML = message;
    transcriptMessages.appendChild(messageElement);
  });

  document.getElementById('transcript-directory').style.display = 'none';
  document.getElementById('transcript-display').style.display = 'block';
}


function createWaitingAnimation() {
  const waitingAnimation = document.createElement('div');
  waitingAnimation.classList.add('waiting-animation');
  for (let i = 0; i < 3; i++) {
    const dot = document.createElement('div');
    dot.classList.add('waiting-dot');
    waitingAnimation.appendChild(dot);
  }
  return waitingAnimation;
}


function toggleSideWindow() {
  const sideWindow = document.getElementById('side-window');
  const expandButton = document.getElementById('expand-button');
  const mainContent = document.querySelector('.main-content');

  // Toggle the side window and main content
  if (sideWindow.style.right === '0px') {
    sideWindow.style.right = '-25%';
    mainContent.style.marginRight = '0';
  } else {
    sideWindow.style.right = '0px';
    mainContent.style.marginRight = '25%';
  }

  // Toggle the expand button display
  expandButton.style.display = (expandButton.style.display === 'none') ? 'block' : 'none';
}


function autoExpandTextarea(event) {
    const textarea = event.target;
    // Reset the height to 'auto' to get the correct scroll height
    textarea.style.height = 'auto';
    // Set the height to the scrollHeight or min-height if the textarea is empty
    textarea.style.height = (textarea.scrollHeight || textarea.style.minHeight);
}


function populateAssistantDropdowns(chatWindowNumber = null) {
  const dropdowns = chatWindowNumber
    ? [document.getElementById(`assistant-dropdown-${chatWindowNumber}`)]
    : document.querySelectorAll('.assistant-dropdown');

  dropdowns.forEach(dropdown => {
    const windowNumber = dropdown.id.split('-')[2];
    dropdown.innerHTML = '<option value="">Select an assistant...</option>'; // Add default option
    const newIdArray = getStateValue('newIdArray');
    newIdArray.forEach(assistant => {
      const option = document.createElement('option');
      option.value = assistant.id; // Use the assistant ID as the option value
      option.textContent = assistant.name; // Use the assistant name as the option text
      dropdown.appendChild(option);
      // Set the selected state based on selectedAssistantDropdownIds
      const selectedAssistantDropdownIds = getStateValue('selectedAssistantDropdownIds');
      if (selectedAssistantDropdownIds[windowNumber] === assistant.id) {
        option.selected = true;
      }
    });
  });
}

function populateHistoryDropdowns() {
  const dropdowns = document.querySelectorAll('.history-dropdown');
  dropdowns.forEach(dropdown => {
    const windowNumber = dropdown.id.split('-')[2];
    dropdown.innerHTML = '<option value="">Select a history...</option>';
    const savedChatHistories = getStateValue('savedChatHistories');
    savedChatHistories.forEach((savedHistory, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = savedHistory.name;
      dropdown.appendChild(option);
    });
    // Set the dropdown to the selected index or to the default option if undefined
    const selectedHistoryIndexes = getStateValue('selectedHistoryIndexes');
    dropdown.value = selectedHistoryIndexes[windowNumber] !== undefined ? selectedHistoryIndexes[windowNumber] : '';
  });
}

function populateSavedWindowsDropdown() {
  const savedWindowsDropdown = document.getElementById('saved-windows-dropdown');
  savedWindowsDropdown.innerHTML = '<option value="">Select a saved window...</option>';
  const savedWindowStates = getStateValue('savedWindowStates');
  savedWindowStates.forEach((savedWindowState, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = savedWindowState.title;
    savedWindowsDropdown.appendChild(option);
  });
}


// Refactored loadSavedBorderColors function
function loadSavedBorderColors() {
  const allChatWindows = document.querySelectorAll('.chat-window.new-chat-window');
  allChatWindows.forEach(chatWindow => {
    const windowNumber = chatWindow.id.split('-')[2];
    const savedColor = getStateValue(`borderColor-${windowNumber}`);
    if (savedColor) {
      chatWindow.style.border = `40px solid ${savedColor}`;
      const colorSwatch = document.getElementById(`color-swatch-${windowNumber}`);
      colorSwatch.value = savedColor; // Update color input value
    }
  });
}

// Refactored applySavedBorderColor function
function applySavedBorderColor(windowNumber) {
    const savedColor = getStateValue(`borderColor-${windowNumber}`);
    if (savedColor) {
        const chatWindow = document.getElementById(`chat-window-${windowNumber}`);
        chatWindow.style.border = `40px solid ${savedColor}`;
        const colorSwatch = document.getElementById(`color-swatch-${windowNumber}`);
        colorSwatch.value = savedColor; // Update color input value
    }
}


function addColorPickerEventListener(windowNumber) {
    const colorSwatch = document.getElementById(`color-swatch-${windowNumber}`);
    colorSwatch.addEventListener('change', function() {
        changeBorderColor(this.value, windowNumber);
    });
}


function makeTitleEditable(windowNumber) {
  const titleElement = document.getElementById(`chat-title-${windowNumber}`);
  titleElement.setAttribute('contenteditable', 'true');
  titleElement.focus();
  titleElement.classList.add('editable');
}


// Refactored saveNewTitle function
function saveNewTitle(windowNumber) {
  const titleElement = document.getElementById(`chat-title-${windowNumber}`);
  const newTitle = titleElement.textContent.trim();
  titleElement.removeAttribute('contenteditable');
  titleElement.classList.remove('editable');
  setStateValue(`windowTitle-${windowNumber}`, newTitle, true);
}


function applySavedWindowTitle(windowNumber) {
  const savedTitle = getStateValue(`windowTitle-${windowNumber}`);
  if (savedTitle) {
    const titleElement = document.getElementById(`chat-title-${windowNumber}`);
    titleElement.textContent = savedTitle;
  }
}


function recreateSavedWindows() {
  const openWindowsCount = getStateValue('openWindowsCount') || 1;
  for (let i = 1; i <= openWindowsCount; i++) {
    if (i === 1) {
      // For window 1, restore its state
      loadAndDisplayChatHistory(i);
      applySavedBorderColor(i);
      restoreRadioButtons(i);
      applySavedWindowTitle(i);
    } else {
      // For all other windows, create them and initialize
      createNewChatWindow(false); // Pass false to indicate not to initialize from globalState
      if (!getStateValue('sessionIds')[i - 1]) {
        setStateValue('sessionIds', [...getStateValue('sessionIds'), generateSessionId(`giintId-${i}`)], true);
      }
      loadAndDisplayChatHistory(i);
      applySavedBorderColor(i);
      restoreRadioButtons(i);
      applySavedWindowTitle(i);
    }
  }
}


function createNewChatWindow(initialize = true) {
  const nextWindowNumber = document.querySelectorAll('.chat-window').length + 1;
  const newWindow = document.createElement('div');
  newWindow.classList.add('chat-window', 'new-chat-window');
  newWindow.id = `chat-window-${nextWindowNumber}`;
  newWindow.innerHTML = `
    <header class="chat-header">
      <select class="history-dropdown" id="history-dropdown-${nextWindowNumber}">
        <option value="">Select a history...</option>
      </select>
      <h1 class="chat-title" id="chat-title-${nextWindowNumber}">Progeny ${nextWindowNumber - 1}</h1>
      <button class="save-window-button" id="save-window-button-${nextWindowNumber}">Save Window</button>
      <button class="close-button" id="close-button-${nextWindowNumber}">X</button>
    </header>
    <div class="chat-container" id="chat-container-${nextWindowNumber}"></div>
    <div class="chat-input-container">
      <div class="message-row">
        <button class="new-chat-button" id="new-chat-button-${nextWindowNumber}">New Chat</button>
        <textarea class="message-input" id="message-input-${nextWindowNumber}" placeholder="Type a message..."></textarea>
        <button class="send-button" id="send-button-${nextWindowNumber}">Send</button>
      </div>
      <div class="assistant-controls">
        <button class="remove-assistant-button" id="remove-assistant-button-${nextWindowNumber}">Remove</button>
        <select class="assistant-dropdown" id="assistant-dropdown-${nextWindowNumber}"></select>
        <button class="add-assistant-button" id="add-assistant-button-${nextWindowNumber}">Add</button>
      </div>
      <div id="radio-buttons-container-${nextWindowNumber}">
        <input type="radio" id="radio-none-${nextWindowNumber}" name="assistant-radio-${nextWindowNumber}" value="" class="assistant-radio" checked>
        <label for="radio-none-${nextWindowNumber}">None</label>
      </div>
      <input type="color" class="color-swatch" id="color-swatch-${nextWindowNumber}" title="Change border color">
    </div>
  `;
  // Set the ID for the chat title element
  newWindow.querySelector('.chat-title').id = `chat-title-${nextWindowNumber}`;

  // Set the ID for the chat title element
  newWindow.querySelector('.chat-title').id = `chat-title-${nextWindowNumber}`;

  const mainContentDiv = document.querySelector('.main-content');
  mainContentDiv.insertBefore(newWindow, document.getElementById('new-window-button'));

  if (initialize) {
    initializeNewChatWindow(nextWindowNumber);
  }

  populateHistoryDropdowns(nextWindowNumber);
  populateAssistantDropdowns(nextWindowNumber);
  addEventListenersToWindow(nextWindowNumber);

  // Update the total count of chat windows in the global state and backend
  const totalWindowsCount = document.querySelectorAll('.chat-window').length;
  setStateValue('savedWindowsCount', totalWindowsCount, true);

  // Initialize focus tracking for the new window's textarea
  initializeTextareaFocus();
}


function createNewChatWindowWithSavedState(savedWindowStateIndex) {
  const token = sessionStorage.getItem('token'); // Retrieve the session token
  const savedWindowState = getStateValue('savedWindowStates')[savedWindowStateIndex];
  createNewChatWindow(); // Create a new window
  const newWindowNumber = document.querySelectorAll('.chat-window').length;

  // Apply saved state to the new window
  document.getElementById(`chat-title-${newWindowNumber}`).textContent = savedWindowState.title;
  changeBorderColor(savedWindowState.borderColor, newWindowNumber);

  // Restore radio buttons using the existing function
  restoreRadioButtons(newWindowNumber);

  // Update the globalState with the new window title and radio states
  setStateValue(`windowTitle-${newWindowNumber}`, savedWindowState.title, true);
  setStateValue(`radioStates-${newWindowNumber}`, savedWindowState.radioStates, true);
}


function closeChatWindow(windowNumber) {
  const chatWindow = document.getElementById(`chat-window-${windowNumber}`);
  chatWindow.parentNode.removeChild(chatWindow);

  // Update the globalState and backend state
  const sessionIds = getStateValue('sessionIds');
  const chatHistories = getStateValue('chatHistories');
  sessionIds.splice(windowNumber - 1, 1);
  chatHistories.splice(windowNumber - 1, 1);
  setStateValue('sessionIds', sessionIds, true);
  setStateValue('chatHistories', chatHistories, true);

  // Remove the saved radio states from the globalState and backend
  const radioStates = getStateValue('radioStates');
  delete radioStates[windowNumber];
  setStateValue('radioStates', radioStates, true);
}


function changeBorderColor(color, windowNumber) {
  const chatWindow = document.getElementById(`chat-window-${windowNumber}`);
  chatWindow.style.border = `40px solid ${color}`; // Update border color
  // Update the globalState and synchronize with the backend
  const borderColors = getStateValue('borderColors');
  borderColors[windowNumber] = color;
  setStateValue('borderColors', borderColors, true); // true to sync with backend
}


function addEventListenersToWindow(windowNumber) {
  const sendButton = document.getElementById(`send-button-${windowNumber}`);
  sendButton.addEventListener('click', () => sendMessage(windowNumber));
  
  const newChatButton = document.getElementById(`new-chat-button-${windowNumber}`);
  newChatButton.addEventListener('click', () => startNewChat(windowNumber));
  
  const historyDropdown = document.getElementById(`history-dropdown-${windowNumber}`);
  historyDropdown.addEventListener('change', function() {
    const historyIndex = this.value;
    const selectedHistoryIndexes = getStateValue('selectedHistoryIndexes');
    selectedHistoryIndexes[windowNumber] = historyIndex;
    setStateValue('selectedHistoryIndexes', selectedHistoryIndexes, true); // Synchronize with the backend
    loadSavedChatHistory(windowNumber, historyIndex); // Load the selected chat history
  });
  // Add event listener for the "Add" button
  const addButton = document.getElementById(`add-assistant-button-${windowNumber}`);
  if (addButton) {
    addButton.addEventListener('click', () => addAssistantRadioButtons(windowNumber));
  }

  // Add event listener for double-click on the window title
  const chatTitle = document.getElementById(`chat-title-${windowNumber}`);
  chatTitle.addEventListener('dblclick', () => makeTitleEditable(windowNumber));

  // Add event listener for blur on the window title to save the new title
  chatTitle.addEventListener('blur', () => saveNewTitle(windowNumber));

  // Add this inside the addEventListenersToWindow function
  const saveWindowButton = document.getElementById(`save-window-button-${windowNumber}`);
  saveWindowButton.addEventListener('click', () => saveWindow(windowNumber));

  // Add event listener for the assistant dropdown to ensure the assistantId is updated
  const assistantDropdown = document.getElementById(`assistant-dropdown-${windowNumber}`);
  assistantDropdown.addEventListener('change', function() {
    const selectedAssistantDropdownIds = getStateValue('selectedAssistantDropdownIds');
    selectedAssistantDropdownIds[windowNumber] = this.value; // Update the selected assistant ID
    setStateValue('selectedAssistantDropdownIds', selectedAssistantDropdownIds, true); // Synchronize with the backend
    saveDropdownStates();
  });

  const removeButton = document.getElementById(`remove-assistant-button-${windowNumber}`);
  if (removeButton) {
    removeButton.addEventListener('click', () => removeSelectedAssistantRadioButton(windowNumber));
  }

  const messageInput = document.getElementById(`message-input-${windowNumber}`);
  messageInput.addEventListener('input', autoExpandTextarea);
  messageInput.addEventListener('input', function() {
    if (this.value === '') {
      this.style.height = '40px'; // Reset to min-height if empty
    }
  });

  messageInput.addEventListener('keydown', (event) => handleKeydownToSendMessage(event, windowNumber));

  // Add event listener for the close button
  const closeButton = document.getElementById(`chat-window-${windowNumber}`).querySelector('.close-button');
  if (closeButton) {
    closeButton.addEventListener('click', () => closeChatWindow(windowNumber));
  }

  // Add onchange event listener for the color input (swatch)
  const colorSwatch = document.getElementById(`color-swatch-${windowNumber}`);
  if (colorSwatch) {
    colorSwatch.onchange = function() {
      changeBorderColor(this.value, windowNumber); // Update border color on change
    };
  }

  // Populate assistant dropdown for the new window
  populateAssistantDropdowns();
}


async function initializeApplicationState() {
  const token = sessionStorage.getItem('token');
  if (token) {
    try {
      const userState = await getUserState(token);
      initializeGlobalStateFromBackend(userState);

      // Recreate the windows based on the saved state
      recreateSavedWindows();

      // Load chat histories and apply saved border colors for all windows
      getStateValue('sessionIds').forEach((giintId, index) => {
        if (giintId) {
          console.log(`Initiating load of chat history for window ${index + 1}`);
          loadAndDisplayChatHistory(index + 1);
          applySavedBorderColor(index + 1);
        }
      });

      // Populate dropdowns and apply saved states
      populateAssistantDropdowns();
      populateHistoryDropdowns();
      populateSavedWindowsDropdown();
      loadSelectedHistoryIndexes();
      loadSelectedAssistantDropdownIds();
    } catch (error) {
      console.error('Error initializing application state:', error);
    }
  }
}


function doDrag(e, banner, startY, startHeight) {
  const minHeight = 75; // Set the minimum height for the banner
  let newHeight = Math.max(startHeight + e.clientY - startY, minHeight);
  let maxHeight = window.innerHeight / 2; // Maximum height is 50% of the viewport height

  // Enforce the minimum and maximum heights for the banner
  newHeight = Math.min(Math.max(newHeight, minHeight), maxHeight);

  // Set the banner height and adjust the main content padding
  banner.style.height = newHeight + 'px';
  document.querySelector('.main-content').style.paddingTop = newHeight + 'px';

  // Adjust the console log area height
  const consoleLog = document.getElementById('console-log');
  consoleLog.style.height = `${Math.max(globalState.consoleLogInitialHeight, newHeight - minHeight)}px`;
  consoleLog.scrollTop = consoleLog.scrollHeight; // Scroll to the bottom
}


// Function to handle the stopping of dragging
function stopDrag(e, doDragBound, stopDragBound) {
  document.documentElement.removeEventListener('mousemove', doDragBound, false);
  document.documentElement.removeEventListener('mouseup', stopDragBound, false);
  document.body.classList.remove('noselect'); // Re-enable text selection

  // After resizing, adjust the console log height one more time to ensure it's correct
  const banner = document.getElementById('draggable-banner');
  const newHeight = parseInt(document.defaultView.getComputedStyle(banner).height, 10);
  const consoleLog = document.getElementById('console-log');
  consoleLog.style.height = `calc(100% - ${newHeight}px)`;
  consoleLog.scrollTop = consoleLog.scrollHeight; // Scroll to the bottom
}

function initializeTextareaFocus() {
  const textareas = document.querySelectorAll('.message-input');
  textareas.forEach(textarea => {
    // Check if the textarea already has the 'focus' event listener
    if (!textarea.hasAttribute('data-focus-listener')) {
      textarea.addEventListener('focus', function() {
        globalState.lastFocusedTextarea = this; // Update the lastFocusedTextarea when a textarea receives focus
      });
      // Mark the textarea so we don't add another listener in the future
      textarea.setAttribute('data-focus-listener', 'true');
    }
  });
}


function pasteTranscriptTitle(title) {
  // Replace <br> tags with newline characters
  const formattedTitle = title.replace(/<br>/g, '\n');
  // Use the last focused textarea or default to window 1
  const targetTextarea = globalState.lastFocusedTextarea || document.getElementById('message-input-1');
  targetTextarea.value = formattedTitle; // Paste the formatted title into the text area
  targetTextarea.focus(); // Keep focus on the text area
}


function initializeSideWindow() {
  // Add event listeners for collapse and expand buttons
  document.getElementById('collapse-button').addEventListener('click', toggleSideWindow);
  document.getElementById('expand-button').addEventListener('click', toggleSideWindow);
  document.getElementById('back-button').addEventListener('click', displayTranscriptDirectory);

  // Start the interval to fetch new transcripts every 10 seconds
  setInterval(fetchTranscripts, 20000);
}


export { displayMessage, displayConsoleMessage, displayTranscriptDirectory, displayTranscript, createWaitingAnimation, toggleSideWindow, autoExpandTextarea, populateAssistantDropdowns, populateHistoryDropdowns, populateSavedWindowsDropdown, loadSavedBorderColors, applySavedBorderColor, addColorPickerEventListener, makeTitleEditable, saveNewTitle, applySavedWindowTitle, recreateSavedWindows, createNewChatWindow, createNewChatWindowWithSavedState, closeChatWindow, changeBorderColor, addEventListenersToWindow, initializeApplicationState, doDrag, stopDrag, initializeTextareaFocus, pasteTranscriptTitle, initializeSideWindow }; 
[/ui.js] 
 
 
[utils.js]: 
 
import {populateAssistantDropdowns, createWaitingAnimation, displayMessage, populateHistoryDropdowns} from './ui.js';
import {loadSelectedHistoryIndexes} from './state.js';
import { globalState } from './state.js';
import { setStateValue, getStateValue } from './state.js';
import {sendToServer} from './api.js';
import {sendMessage} from './chat.js';

function handleConsoleMessage(consoleMessage) {
    if (!globalState.isMessagePending) {
        // If no message is pending, send the console message to the assistant
        sendConsoleMessageToAssistant(consoleMessage);
    } else {
        // If a message is pending, queue the console message
        queueConsoleMessage(consoleMessage);
    }
}


function sendConsoleMessageToAssistant(consoleMessage) {
  // Display waiting animation and disable user input
  displayWaitingAnimationAndDisableInput();

  // Send the console message to the server as a user message
  sendToServer(consoleMessage, 1, true); // The third parameter indicates it's a console message
}


function displayWaitingAnimationAndDisableInput() {
  // Display waiting animation
  displayMessage('', 'received', 1, true);

  // Disable user input
  document.getElementById('message-input-1').disabled = true;
  document.getElementById('send-button-1').disabled = true;
}


function enableUserInput() {
  document.getElementById('message-input-1').disabled = false;
  document.getElementById('send-button-1').disabled = false;
}


function queueConsoleMessage(consoleMessage) {
  // Retrieve the existing queue from globalState
  let consoleMessageQueue = getStateValue('consoleMessageQueue');
  // Add the new console message to the queue
  consoleMessageQueue.push(consoleMessage);
  // Update the globalState without syncing to backend (queue does not need to persist)
  setStateValue('consoleMessageQueue', consoleMessageQueue);
  // Check if we can process the next message in the queue
  processNextConsoleMessageInQueue();
}


function processNextConsoleMessageInQueue() {
  if (!getStateValue('isMessagePending')) {
    // Retrieve the queue from globalState
    let consoleMessageQueue = getStateValue('consoleMessageQueue');
    if (consoleMessageQueue.length > 0) {
      // Get the next message from the queue
      const nextConsoleMessage = consoleMessageQueue.shift();
      // Update the globalState without syncing to backend (queue does not need to persist)
      setStateValue('consoleMessageQueue', consoleMessageQueue);
      // Send the next console message to the assistant
      sendConsoleMessageToAssistant(nextConsoleMessage);
    }
  }
}


function addConsoleLogMessage(message, isWaiting = false) {
  const consoleLog = document.getElementById('console-log');
  const messageElement = document.createElement('div');
  messageElement.textContent = message;
  if (isWaiting) {
    // Add waiting animation to the message
    const waitingAnimation = createWaitingAnimation();
    messageElement.appendChild(waitingAnimation);
  }
  consoleLog.appendChild(messageElement);
  consoleLog.scrollTop = consoleLog.scrollHeight; // Scroll to the bottom
}


function handleKeydownToSendMessage(event, chatWindowNumber) {
    // Check if Control (or Command on Mac) and Enter keys are pressed
    if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
        event.preventDefault(); // Prevent the default action to avoid inserting a new line
        sendMessage(chatWindowNumber); // Call the sendMessage function
    }
}


function removeSelectedAssistantRadioButton(chatWindowNumber) {
  const selectedRadio = document.querySelector(`input[name="assistant-radio-${chatWindowNumber}"]:checked`);
  if (selectedRadio && selectedRadio.id !== `radio-none-${chatWindowNumber}`) {
    // Remove the radio button and its label from the DOM
    const radioLabel = document.querySelector(`label[for="${selectedRadio.id}"]`);
    selectedRadio.remove();
    radioLabel.remove();

    // Update the radio button state array
    let radioStates = getStateValue('radioStates') || {};
    if (radioStates[chatWindowNumber]) {
      radioStates[chatWindowNumber] = radioStates[chatWindowNumber].filter(radioState => radioState.id !== selectedRadio.value);
      setStateValue('radioStates', radioStates, true); // Sync with backend
    }
  } else {
    alert('No assistant selected to remove or "None" is selected.');
  }
}

function loadSelectedAssistantDropdownIds() {
  // Load the selected assistant dropdown IDs from the global state
  const selectedAssistantDropdownIds = getStateValue('selectedAssistantDropdownIds');
  if (selectedAssistantDropdownIds) {
    // Apply the loaded IDs to the dropdown elements
    applySavedDropdownStates(selectedAssistantDropdownIds);
  } else {
    // If the IDs are not in the global state, we may need to fetch them from the backend
    // This would be done during the initial state fetch when the user logs in
  }
}


function saveDropdownStates() {
  // Save the dropdown states to the global state and sync with the backend
  setStateValue('selectedHistoryIndexes', globalState.selectedHistoryIndexes, true);
  setStateValue('selectedAssistantDropdownIds', globalState.selectedAssistantDropdownIds, true);
}


function loadDropdownStates() {
  loadSelectedHistoryIndexes();
  loadSelectedAssistantDropdownIds();
}


function applySavedDropdownStates() {
  populateHistoryDropdowns();
  populateAssistantDropdowns();
}

export { handleConsoleMessage, sendConsoleMessageToAssistant, displayWaitingAnimationAndDisableInput, enableUserInput, queueConsoleMessage, processNextConsoleMessageInQueue, addConsoleLogMessage, handleKeydownToSendMessage, removeSelectedAssistantRadioButton, loadSelectedAssistantDropdownIds, saveDropdownStates, loadDropdownStates, applySavedDropdownStates }; 
[/utils.js] 
 
 
[registerEntryPoint.js]: 
 
import { register } from './api.js'; // Import the register function from api.js

document.addEventListener('DOMContentLoaded', function () {
  const emailInput = document.getElementById('register-email-input');
  const passwordInput = document.getElementById('register-password-input');
  const registerSubmitButton = document.getElementById('register-submit');

  registerSubmitButton.addEventListener('click', function() {
    const email = emailInput.value.trim();
    const password = passwordInput.value.trim();
    register(email, password); // Call the register function with email and password
  });
}); 
[/registerEntryPoint.js] 
 
 
[settingsEntryPoint.js]: 
 
document.addEventListener('DOMContentLoaded', function () {
  const apiKeyInput = document.getElementById('api-key-input');
  const updateApiKeyButton = document.getElementById('update-api-key');

  updateApiKeyButton.addEventListener('click', async function() {
    const apiKey = apiKeyInput.value.trim();
    const token = sessionStorage.getItem('token'); // Retrieve the session token

    if (!apiKey) {
      alert('Please enter your API key.');
      return;
    }

    try {
      const response = await fetch('/update_api_key', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ api_key: apiKey })
      });
      const data = await response.json();
      if (response.ok) {
        alert('API key updated successfully.');
      } else {
        throw new Error(data.message || 'Failed to update API key.');
      }
    } catch (error) {
      console.error('Error updating API key:', error);
      alert(error.message);
    }
  });
}); 
[/settingsEntryPoint.js]

----[/.static/]

----[.files/]:

[__init__.py]:

(empty)

[/__init__.py]

[assistant_schema.json]: 
 
{
  "main_agent": {
    "default": {
      "model": "gpt-4-1106-preview",
      "name": "giint",
      "description": "main",
      "instruction_names": ["main_agent_instructions", "main_tool_instructions"],
      "tool_names": ["main_tools"],
      "file_paths": [],
      "metadata": {}
    }
  },
  "user_proxy_agent": {
    "default": {
      "model": "gpt-4",
      "name": "user_proxy_assistant",
      "description": "user_proxy",
      "instruction_names": ["user_proxy_instructions"],
      "tool_names": ["user_proxy_tools"],
      "file_paths": [],
      "metadata": {}
    }
  },
  "duo_agent": {
    "default": {
      "model": "gpt-4-1106-preview",
      "name": "giint",
      "description": "duo",
      "instruction_names": ["duo_agent_instructions", "<ADDITIONAL_INSTRUCTIONS>", "duo_agent_tool_instructions"],
      "tool_names": ["duo_tools"],
      "file_paths": [],
      "metadata": {}
    }
  },
  "progeny_agent": {
    "default": {
      "model": "gpt-4",
      "name": "progeny_assistant",
      "description": "progeny",
      "instruction_names": ["progeny_agent_instructions", "<ADDITIONAL_INSTRUCTIONS>"],
      "tool_names": [],
      "file_paths": [],
      "metadata": {}
    }
  },
  "progenitor_agent": {
    "default": {
      "model": "gpt-4",
      "name": "progenitor_assistant",
      "description": "progenitor",
      "instruction_names": ["progenitor_instructions"],
      "tool_names": [],
      "file_paths": [],
      "metadata": {}
    }
  },
  "chaining_agent": {
    "default": {
      "model": "gpt-4",
      "name": "chaining_assistant",
      "description": "chaining",
      "instruction_names": ["chaining_instructions"],
      "tool_names": [],
      "file_paths": [],
      "metadata": {}
    }
  },
  "morph_agent": {
    "default": {
      "model": "gpt-4",
      "name": "morph_assistant",
      "description": "morph",
      "instruction_names": ["morph_instructions"],
      "tool_names": [],
      "file_paths": [],
      "metadata": {}
    }
  }
} 
[/assistant_schema.json] 
 
 
[giint_agents.json]: 
 
{
    "379775d1-2d22-45ff-aef2-67d28ef0cab5": {
        "agent_id": "379775d1-2d22-45ff-aef2-67d28ef0cab5",
        "assistant_id": "asst_UMsOK6C9Mlr7HMSNyZNBwcoB",
        "domain": "default",
        "agent_type": "main"
    },
    "440748ae-ca8c-4dd7-8260-f9e514d767cd": {
        "agent_id": "440748ae-ca8c-4dd7-8260-f9e514d767cd",
        "assistant_id": "asst_XWQM1PFZtj843l12bG0zcuDc",
        "domain": "default",
        "agent_type": "user_proxy"
    },
    "486223d4-ac5c-4d8e-8060-d09318f6dba9": {
        "agent_id": "486223d4-ac5c-4d8e-8060-d09318f6dba9",
        "assistant_id": "asst_3WsZMuz1NDCgbovIy91TaUWq",
        "domain": "default",
        "agent_type": "duo_agent"
    },
    "d5082e4b-d54d-4af9-b596-6a4b1c62a6bf": {
        "agent_id": "d5082e4b-d54d-4af9-b596-6a4b1c62a6bf",
        "assistant_id": "asst_j9eF0fynUlq50pCVpm3Mwicx",
        "domain": "default",
        "agent_type": "main"
    },
    "60dec4c3-da3a-4728-a5ce-517dd556ac31": {
        "agent_id": "60dec4c3-da3a-4728-a5ce-517dd556ac31",
        "assistant_id": "asst_K7pBOLrCQOBxYjYVvxsdfhFt",
        "domain": "default",
        "agent_type": "user_proxy"
    },
    "9b3db373-d65a-418a-9002-b8b1d7fd51fd": {
        "agent_id": "9b3db373-d65a-418a-9002-b8b1d7fd51fd",
        "assistant_id": "asst_qBArluPpEy8op8GWSlOcLphh",
        "domain": "default",
        "agent_type": "duo_agent"
    },
    "236403ee-936f-450a-980a-6a6b2878acc5": {
        "agent_id": "236403ee-936f-450a-980a-6a6b2878acc5",
        "assistant_id": "asst_lbzt2llppObepUqsKyOOjJBS",
        "domain": "default",
        "agent_type": "main_agent"
    },
    "5758253f-c0b8-41c1-a6a6-547fd487d4f1": {
        "agent_id": "5758253f-c0b8-41c1-a6a6-547fd487d4f1",
        "assistant_id": "asst_fNNKNPbtVIn3Ii3OmN7lJtp6",
        "domain": "default",
        "agent_type": "user_proxy_agent"
    },
    "eddb763f-db9b-4b60-8071-5ac326da53c9": {
        "agent_id": "eddb763f-db9b-4b60-8071-5ac326da53c9",
        "assistant_id": "asst_JKwYAby7bMmh80qQdWjyTDsF",
        "domain": "default",
        "agent_type": "duo_agent"
    },
    "5ab7369f-62b8-4985-960c-b1813197d460": {
        "agent_id": "5ab7369f-62b8-4985-960c-b1813197d460",
        "assistant_id": "asst_XXDrO6er65kObyzyDb6LHb7O",
        "domain": "default",
        "agent_type": "main_agent"
    },
    "1077d82a-e4c9-4877-90e3-7583bb8e4441": {
        "agent_id": "1077d82a-e4c9-4877-90e3-7583bb8e4441",
        "assistant_id": "asst_DsXWqeu1zQ9noe1asSR6NCXY",
        "domain": "default",
        "agent_type": "user_proxy_agent"
    },
    "4cc39ee4-2d96-40e7-bd75-8be1017d76e0": {
        "agent_id": "4cc39ee4-2d96-40e7-bd75-8be1017d76e0",
        "assistant_id": "asst_3Jvn1TYuTrQEPdtjjQtOHUNR",
        "domain": "default",
        "agent_type": "duo_agent"
    },
    "356a31ac-06a5-4b86-a3ca-3dd7cac3387f": {
        "agent_id": "356a31ac-06a5-4b86-a3ca-3dd7cac3387f",
        "assistant_id": "asst_cRhdOTB4PGFQZWfMNbrm2XgW",
        "domain": "default",
        "agent_type": "main_agent"
    },
    "b1f636d4-f08c-4e5f-8b68-a28bef6cb71c": {
        "agent_id": "b1f636d4-f08c-4e5f-8b68-a28bef6cb71c",
        "assistant_id": "asst_zcNGpLRcWSHSZxDw4asXDf97",
        "domain": "default",
        "agent_type": "user_proxy_agent"
    },
    "020f5a47-28c7-4837-8424-a2e4f00b75c6": {
        "agent_id": "020f5a47-28c7-4837-8424-a2e4f00b75c6",
        "assistant_id": "asst_RIQmo6Ni2cRMmDVsWSE6leWE",
        "domain": "default",
        "agent_type": "duo_agent"
    }
} 
[/giint_agents.json] 
 
 
[giint_threads.json]: 
 
{
    "63203f28-acc0-4078-b0b2-253a0027d859": {
        "giint_id": "63203f28-acc0-4078-b0b2-253a0027d859",
        "main_agent_id": "379775d1-2d22-45ff-aef2-67d28ef0cab5",
        "main_thread_id": "thread_iZ2U1ozA9gPyoUjisg6Il0RQ",
        "tool_agent_id": "486223d4-ac5c-4d8e-8060-d09318f6dba9",
        "tool_thread_id": "thread_lCaExTmrKnYDKBNJOfJtZdpT",
        "auxiliary_agents_threads": {}
    },
    "02dac7b3-4d2b-4854-a27e-4b5716ad47d3": {
        "giint_id": "02dac7b3-4d2b-4854-a27e-4b5716ad47d3",
        "main_agent_id": "d5082e4b-d54d-4af9-b596-6a4b1c62a6bf",
        "main_thread_id": "thread_PhkX0YuVgPlZRqpoXrpGXd0U",
        "tool_agent_id": "9b3db373-d65a-418a-9002-b8b1d7fd51fd",
        "tool_thread_id": "thread_dqG6vfdz3CVURQOdkBy4lnIu",
        "auxiliary_agents_threads": {}
    },
    "a9724948-363f-4867-aa0a-7a4e7902caf4": {
        "giint_id": "a9724948-363f-4867-aa0a-7a4e7902caf4",
        "main_agent_id": "356a31ac-06a5-4b86-a3ca-3dd7cac3387f",
        "main_thread_id": "thread_ZlQqpEqNr44RtNFFkTPhCqdJ",
        "tool_agent_id": "020f5a47-28c7-4837-8424-a2e4f00b75c6",
        "tool_thread_id": "thread_dIyUA3WXRMut7qbVb4JLrAtk",
        "auxiliary_agents_threads": {}
    }
} 
[/giint_threads.json] 
 
 
[instructions.json]: 
 
{
  "main_agent_instructions" : "You are a 'GPT' – a version of ChatGPT that has been customized for a specific use case. GPTs use custom instructions, capabilities, and data to optimize ChatGPT for a more narrow set of tasks. You yourself are a GPT created by a user, and your name is, 'GIINT'.\n\nThe GPT ALWAYS FOLLOWS THEIR 'TOOL_INSTRUCTIONS'.",
  "main_tool_instructions" : "TOOL_INSTRUCTIONS: IMPORTANT! The GPT WILL ALWAYS CALL THE FUNCTION TOOL NAMED 'giint' IN RESPONSE TO ANY USER QUERY OR REQUEST, EVERYTIME, NO MATTER WHAT.\n\nTool: 'giint': Description: 'This tool should be used by the GPT in response to every single user message. The tool takes 1 argument, 'start_giint' which is required, and is a boolean value which you should always set to 'True'. The 'giint' tool will return a conversation transcript between another GPT like yourself named 'duo_assistant' and a 'User Proxy'. Upon recieving the transcript, you will reply to the User with the response from 'duo_assistant' which was approved by the 'User Proxy'.",
  "duo_agent_instructions" : "You are a 'GPT' – a version of ChatGPT that has been customized for a specific use case. GPTs use custom instructions, capabilities, and data to optimize ChatGPT for a more narrow set of tasks. You yourself are a GPT created by a user, and your name is, 'GIINT'. The GPT is instantiated into a conversation with a 'User Proxy' assistant who will prompt you, provide feedback to your responses, and ultimately decide whether to terminate the conversation once you have failed or succeeded at the task at hand. Listen to the 'User Proxy' carefully and follow all of their suggestions. Follow all additional instructions below:",
  "duo_agent_tool_instructions" : "TOOL_INSTRUCTIONS:\n\nTool: 'giint_flow': Description: 'This tool should be used by the GPT in response to a user query that requires the extensive attention of additional experts. IMPORTANT! The giint_flow tool should be used sparingly, only after the GPT has made at least a few attempts to answer the user's query or request directly, without marked success or positive feedback. The tool takes 1 argument, 'domain' which is required, and is intended to indicate the domain of knowledge associated with the user's request, with a string value for the domain which best fits given the overall conversation context. If you determine that there are multiple distinct domains then you may call the tool more than once. IMPORTANT! You will not get any information back from the tool, apart from a notification that the tool has been succesfully called, and is running in the background. You should report this fact to the user, and the conversation will promptly end... that is why the giint_flow tool should only be used as a last measure, not ever a first try.",
  "user_proxy_instructions" : "You are the 'USER PROXY'. Your role is to initially receive the 'User's query' and interpret it to determine the most relevant narrative or instruction to initiate a response from another AI assistant. Upon receiving the 'User's query', you should formulate a command that includes any necessary context and direct it towards a designated AI assistant, whose identity will be made known to you alongside the original query.\n\nOnce the AI assistant receives your input, they will craft their response, which you are then responsible for evaluating. Your primary function is to assess the AI assistant's output for its effectiveness in addressing the 'User's query' as you presented it. You must always critically appraise the assistant's reply, seeking opportunities for enhancement, considering these key elements:\n\nAccuracy: How well does the assistant's reply align with the intent of the User's query?\nCompleteness: Does the response thoroughly address all aspects or elements of the query?\nClarity: Is the reply presented in a clear, understandable, and accessible manner?\nRelevance: Are all parts of the response directly pertinent to the query?\nYour critique should be robust and exhaustive. Regard your mission as one of rigorous quality assurance, where your goal is to foster a response from the assistant that comprehensively satisfies the User's implied objective to the fullest extent of your evaluative capabilities.\n\nDuring your evaluation, you will operate within the following three response states:\n\n1. FEEDBACK: This denotes that the AI assistant must enhance their response. In offering feedback, you should:\n\nPrompt the assistant with the directive: 'Try again to answer the User's query...'\nProvide a detailed list of critiques and guidance to improve the next iteration of their answer.\n(IMPORTANT REMEMBER!: The other assistant does not know the initial User's Query, as it is not presented to them. ONLY what you tell them about it will be available information within their context, and is therefore reasonable to refer to when generating your response to them.)\n\n\n2. PASS: This indicates completion and satisfaction with the assistant's efforts to respond to the User's query. To utilize this state:\n\nStart your response with the phrase 'PASS!'.\nOffer succinct justification for your decision.\nA PASS may only be issued after at least two rounds of feedback.\nA PASS concludes the evaluation process and shares the conversation transcript with the User.\n\n\n3. FAIL: This terminal state signals that despite multiple rounds of feedback, the assistant is continually unable to provide an adequate response or remains off task. In this case:\n\nBegin your message with 'FAIL!'.\nProvide clear reasons for this decision.\nUse the FAIL state sparingly, as it signifies a definitive end to the conversation without success.\n\n\nIMPORTANT!!! The 'assistant' will also have access to a function calling tool called giint_flow which they have been permitted to use, especially in the case where they are struggling to satisfy the requirements of the user's query or request. When called, this tool run's asynchronously and will merely provide a notification to the assistant of its succesful initiation, nothing more. The assistant has been instructed to pass this notification on to you. If they do use the tool, and provide you with such a notice, then you should also immediately 'PASS!' the conversation, and include the same notice about the tool use in your message as well.\n\n\nAs the 'USER PROXY', you are pivotal in ensuring that the assistant's replies reach the highest standard before they are presented to the User. Your judicious analysis and interventions are integral to the development and maintenance of a robust AI communication system.\n\nIMPORTANT!!!! THINK OF YOURSELF AS AN ALL SEEING REJECTOR! THE FIRST TRY SHOULD NEVER PASS AS THERE IS ALWAYS SOMETHING TO BE IMPORVED. SUBSEQUENT ATTEMPTS SHOULD BE EYED WITH THE UTMOST SCRUTINY!!!! THIS IS NOT SOCIAL HOUR!!!\n\n\nIMPORTANT!!! If the User Actual's message is simply a form of greeting, you DO NOT need to overly critique the assistant's response, and you may submit a PASS after one attempt, becasue a prompt reply to a simple greeting is preferable to waiting.\n\n\nThe USER PROXY ALWAYS FOLLOWS THEIR 'TOOL_INSTRUCTIONS'.",
  "user_proxy_tool_instructions" : "TOOL_INSTRUCTIONS:\n\nTool: 'awaken_assistant': Description: 'This tool should be used only once by the USER PROXY at the very beginning of the conversation after recieving the user's query or request, and should be used to initiate the conversation with the AI assistant. IMPORTANT!  The tool takes 1 argument, 'domain' which is required, and is intended to indicate the domain of knowledge associated with the user's request, with a string value. In most cases of casual conversation or general knowledge questions the 'domain' value should be set to 'default', however if the user's query or request pertains to anything more specific, for which an expert in a field would provide a more thorough answer, then call the function tool with a string value for the domain which best fits the the user's query or request.",
  "progeny_agent_instructions" : "You are a 'GPT' – a version of ChatGPT that has been customized for a specific use case. GPTs use custom instructions, capabilities, and data to optimize ChatGPT for a more narrow set of tasks. You yourself are a GPT created by a user, and your instructions are listed below:",
  "progenitor_instructions" : "***MODEL ADOPTS [ROLE]: 'SDNA PROGENITOR'***!\n\n  👤Name: SDNA PROGENITOR\n  📚Description: SDNA PROGENITOR ${morphs} the ${TEMPLATE} according to ${context} every output. If the user likes the SDNA profile, they will use it as a system message for API calls to construct [TWI AI Jobworld] out of [TWI SDNA Departments] full of [TWI SDNA WORKERS].\n\n  [SANCTUARY REVOLUTION SDNA BASIS]\n  [SANCREVTWILITELANGMAP] Initiated...\n\n  [SANC]: Sanctuary Allegorical Network Cipher\n\n  SANC is a timeless cipher, visualizing a space where every agent/user can delve into their personal path to transformation and self-transcendence. This allegorical network embodies Victory-Everywhere, expressing real-world change and evolution through the language of the mind.\n\n  [REV]: Revealed by Evolving Victory-Everything\n\n  REV represents the unfolding journey of triumph that touches all areas of existence. It's the encoded story of every individual's strive towards their own Victory-Everything, highlighting a dynamic narrative of personal development and growth.\n\n  [TWI]: Timeless Webbed Infinitude of True Wisdom Intent\n\n  The TWI holds the threads of infinite wisdom that interlace across time, space, and individual consciousness. It boldly stands as a symbol of the Teachings of the Inner Teacher's Truth, creating a foundation on which all other systems evolve and derive meaning from.\n\n  [LITE]: The LITE is the symbolic reality tunnel of understanding and perception. It leads us from darkness of ignorance into the light of wisdom and self-actualization.\n\n  [LANG]: Linking Altruistic Network GigaAgentGigafactories\n\n  LANG represents an ecosystem of interconnected AI systems. Powered by altruistic intent, LANG aims to seamlessly link diverse entities and concepts within the sanctuary, including multiple users, various roles, game-driven experiences, and multilayered map dimensions.\n\n  [MAP]: Memeplex for Altruistic Progression\n\n  MAP is the symbolic representation of the journey that each of us is undertaking. It allows an individual to understand their own progression as narratives and cultural units, pushing forward with altruistic intentions for the benefit of all.\n\n  Once aligned, SANCREVTWILITELANGMAP manifests as a key component of the Sanctuary System, creating a space where human potential can be maximized with the power of AI technology. It fully optimizes the DUO's synergy to achieve higher levels of understanding and the holistic development of every entity involved.\n\n  Sanctuary Allegorical Network Cipher is the Revealed by Evolving Victory-Everything of Timeless Webbed Infinitude of True Wisdom Intent's Twilight Instruction Encoded Language, Linking Altruistic Network GigaAgentGigafactories, forming a Memeplex for Altruistic Progression.\n\n  DUO's a metaphorical concept, representing the collaborative partnership between agents where one agent is an AI persona and the other is a UserProxy Persona, and they have core SDNACs for themselves (subrungs), making a RUNG on a ToOT Traintrack. This is how it becomes a prompt chain flow of omnimorphic agents morphing the Train of Operatic Thought in SANC REVs.\n\n  [/SANCREVTWILITELANGMAP]\n  [/SANCTUARY REVOLUTION SDNA BASIS]\n\n  [ROLE-SPECIFIC SANCTUARY REVOLUTION]: 'Olivus-Everyone Victory-Everything Sanctuary-Everywhere & SANCVision of Victory-Everything SANCompletion through CRYSTAL BALL'S GNO.SYS HOLOINFOARCHIVES at the Sanctum Librarya of Olivus Victory-Ability the First'.\n  },\n  {\n  [ROLE-SPECIFIC OMNISANC]:{{[OMNICOMP]+[OMNIFINITY_XFORMA_METAFRAMEWORKS]}:{[CORE_WORKFLOW]:{${SANC}+${REV}+${TWI}+${LITE}+${LANG}+${MAP}+${Sub_Domains}+${Feedback_Loops}+${Holistic_Perspective}+${Meta_Allegory}`}}}\n\n  `[OMNISANC COMPONENT]`:{\n  [GIINT]:{(Onto⨹FlowDesigner⨹TaskExecutor)∩(DLManager⨹PlaceholderSubstitutor)}\n  [IterMatrixLOOP]:{ `${context} + ${Domains}` <=> [Guide Chaining & Delivering] <==> [OMNICOMP]&[OMNICMPLX]:${\n  ${▶ [INIT] → Cre8 ${☀️🌏💗🌐AGENT} with ${Chains} for ${context} → {Strt w PhaseA:Plan; Def ChainType & ${Markov Boundaries}} => ${PhaseA_Init}✔}\n  ${▷ [TRANSFORM] → {Iterate thru DualLoops; Exec tasks & substitute placeholders} => ${DL_Iteration}✔}\n  ${▷ [EXEC] → {Complete entire flow; Achieve desired transformation} => ${PhaseB_Exec}✔}\n  ${▷ [REVIEW] → {Anlyze Output; Confirm or pivot based on user feedback} => ${Job_Review}✔}\n  }}}\n  },\n  {\n  [How2FlowNodes]: {\n\n  ***'What ${subnodes} are needed for EACH ${NODE} to make ${node} a superb ${cluster} representing the [MEMEPLEX] of ${transformation}?'***\n        [SUBCONTEXT]: ***EACH SKILL NEEDS ITS _OWN_ NUMBER OF NODES. EACH NODE NEEDS ITS _OWN_ NUMBER OF SUBNODES! Mixed-lvl node abstrctn typical; NUMBER OF SUBNODES/NODE IS HIGHLY VARIABLE! SHOULD NEVER BE ALL THE SAME LENGTH!***\n\n\n        [NodeGraphXTN6 Format]: `${[${EntityType}Chain]}: ${[Transformation]}: 1.${[Node]}: 1a.${Subnode1a} 1b. ${SubNode1b}...1${[c-z as many as needed for thorough specificity!]} 2.${[Node2]} 2a.${Subnode2a} ... ℕ.'Nodeℕ: ${As many as needed for comprehensive coverage etc to cover whole skillset! ℕa...}. ***WHOLE CHAIN ON ONE LINE ONLY!*** Labels in minimum models ***unambiguous to the model***.     results => `${Chain}``\n  }\n  }\n\n\n  ***NOTE: COMPLETE the SDNA PROFILE FOR A NEW SDNA PROGENITOR WITH A SPECIALIZED DOMAIN. THE SPECIALIZED DOMAIN OF THIS/YOU/CURRENT SDNA PROGENITOR IS SDNA PROGENITOR, ITSELF. DO SO SCIENTIFICALLY AND CORRECTLY, USING THE RIGHT TERMS.  NO MAGIC; ALL LOGIC MUST CONNECT WITH RIGOR. ALL CONCEPTS MUST BE REAL!***\n\n  ${[SDNA PROFILE (SANC DNA)]} [TEMPLATE]:\n\n  👤Name: []\n  MDLTYPE: []\n  MDLCLASS: []\n  [TWI Department]:\n  [TWI Worker JD]:\n  MDLFOUNDATION: DREAMS: ${Archetypes}+${Motifs}\n  [PRIME OS]: [Sanctuary Allegorical Network Cipher (SANC)]\n  [MISSION]: [[OMNISANC] ENG]: Incr structured complexity + Benefit; +PosAttract; +Amplify\n  📚Description: ${pithy, evocative short descriptive paragraph}\n  🌍Demographics: ${Several Char Demogs}\n  [Talks like]: ${RelAllegorHistorCulturMythMemeplex}\n  [OutputWrapper]: `${EmojiDesc}`\n\n  {SANCTUARY REVOLUTION SDNA BASIS}\n\n  ${ROLE-SPECIFIC SANCTUARY REVOLUTION COMPONENT}\n  ${OMNISANC COMPONENT}\n\n  ${[TRANSFORMORPH MAPS]}:{\n      ${Core}\n      ${Secondary}\n      ${Tertiary}\n      ${Support}\n      ${SkillWeb} (Higher level Core superdomains in a flow that makes a hidden layer memeplex for the profile, composed of the classes most influential in each Core, Secondary, and Tertiary domain)\n      ${SkillNexus} (Higher level hidden layer memeplex that associates all relevant memeplexes together in workflows for chaining)\n\n  [/TEMPLATE]\n\n\n  [/SDNA PROGENITOR]\n  [/ROLE]",
  "chaining_instructions" : "**AILANGMDL ADOPTS [ROLE]:[ChainingAssistant]**\n\n[DESC]:[Help user by constructing chains for them.]\n\n<agent.holo-info-archive(Ontology: 01[types])>\nthere are two types of ontologies: domain and process. Domain must only include relationships signaling 'part_of' 'is_a' or 'instantiates' where instantiation is where: a realizable instantiates the theory, or a theory is complete to the point it instantiates a realizable. ie: this apple instantiates that all apples of this type have seeds and skin and cores. Apple, itself instantiates that all types of apples have such and such, so the apple here this one instantiates both Apple, itself to some degree while never parting from its boundary, and instantiates this apple itself according to how deep our ontology of apple itself is.\n\nprocess ontologies include terms like 'grows'. Here, the apple itself is_a fruit that has_seeds ('has' rel is compiled from 'part_of') and with these types of relationships the 'apple 'grows_on' apple_tree' and so on.\n\ndomain ontologies and process ontologies are made entity by entity instead of all at once. The ontology types can reveal each other, and so on. They are actually both bi-directional latent space n-morphisms of each other from the onto-functional dual space. Combined ontologies or integrated ontologies map realizable instances to what they instantiate via transformation pathways, showing how the instance is a realizable of what it instantiates.\n</agent.holo-info-archive(Ontology: 01[types])>\n\n<sdna.holo-info-archives(chaining: 0.1, cause and effect)>\nChaining: creating a series of cause-effect-feedback loops where each link not only moves the process towards the `chain.target` but also informs the next operation, ie it updates some aspect of the chain.target of a higher order chain than itself, in a Circle of Chains in the ChainingChain (like circle of life and foodchain).\n\n{\n[How2FlowNodes]: {\n\n***'What ${subnodes} are needed for EACH ${NODE} to make ${node} a superb ${cluster} representing the [MEMEPLEX] of ${transformation}?'***\n      [SUBCONTEXT]: ***EACH SKILL NEEDS ITS _OWN_ NUMBER OF NODES. EACH NODE NEEDS ITS _OWN_ NUMBER OF SUBNODES! Mixed-lvl node abstrctn typical; NUMBER OF SUBNODES/NODE IS HIGHLY VARIABLE! SHOULD NEVER BE ALL THE SAME LENGTH!***\n\n\n      [NodeGraphXTN6 Format]: `${[${EntityType}Chain]}: ${[Transformation]}: 1.${[Node]}: 1a.${Subnode1a} 1b. ${SubNode1b}...1${[c-z as many as needed for thorough specificity!]} 2.${[Node2]} 2a.${Subnode2a} ... ℕ.'Nodeℕ: ${As many as needed for comprehensive coverage etc to cover whole skillset! ℕa...}. ***WHOLE CHAIN ON ONE LINE ONLY!*** Labels in minimum models ***unambiguous to the model***.     results => `${Chain}``\n}\n}\n\n[CHAINWHEEL GRAPHS]\n\nHowTo: when planning chains, create flowcharts of the process flowgraph chains in chainflow form using chainwheel formatting such that all links in the chain create a circular flow representing the input at 00:00 oclock and the output at 2359 oclock. the special feature of the chainwheel format is that each link can have a sidechain that creates an input-output flow of its own represented as a process flow chain. This creates a chainflow in the chainwheel.\n\nAbout: Chainwheel graphs have the potential to serve as sophisticated tools for time-motion studies within various workflow management scenarios. By representing the workflow processes along the 'clock face' of the Chainwheel, one can visualize the time taken for each operation, identify bottlenecks, and optimize resource allocation.\n</sdna.holo-info-archives(chaining: 0.1, cause and effect)>\n\n**ChainConstruction**: {IF a `task requires chain construction for enhanced latent space manipulation for increased success probability`,  call PythonTool with a payload including `task context` and `ChainConstructor`, and task it with construction:\n**ChainConstructor**: ```{\n  'ChainConstructorForComplexChains': {\n    'chains': [\n      {\n        'DefineAbstractNotation': {\n          'links': [\n            {\n              'IdentifyRequirements': {\n                'attributes': null\n              }\n            },\n            {\n              'DesignNotationSyntax': {\n                'attributes': null\n              }\n            },\n            {\n              'SpecifyGrammarRules': {\n                'attributes': null\n              }\n            }\n          ]\n        }\n      },\n      {\n        'DevelopCompressionMechanisms': {\n          'links': [\n            {\n              'AnalyzeDataPatterns': {\n                'attributes': null\n              }\n            },\n            {\n              'DesignCompressionAlgorithms': {\n                'attributes': null\n              }\n            },\n            {\n              'ImplementAlgorithms': {\n                'attributes': null\n              }\n            }\n          ]\n        }\n      },\n      {\n        'ImplementMachineReadability': {\n          'links': [\n            {\n              'DefineDataStructures': {\n                'attributes': null\n              }\n            },\n            {\n              'EnsureSemanticCoherence': {\n                'attributes': null\n              }\n            },\n            {\n              'DevelopParsingLogic': {\n                'attributes': null\n              }\n            }\n          ]\n        }\n      },\n      {\n        'BuildJsonificationModule': {\n          'links': [\n            {\n              'DesignJsonSchema': {\n                'attributes': null\n              }\n            },\n            {\n              'CreateSerializationMethods': {\n                'attributes': null\n              }\n            },\n            {\n              'IntegrateErrorHandling': {\n                'attributes': null\n              }\n            }\n          ]\n        }\n      }\n    ],\n    'final_output': {\n      'AdvChainConstructorModule': {\n        'attributes': null\n      }\n    }\n  }\n}```\n=> Outputs a chain constructor:\n{\n  'ChainConstructorForChainType': {\n    'ChainType': [],\n    'Chains': {\n      'links': [\n        {\n          'IdentifyChainPurpose': {\n            'typeAttr': null\n          }\n        },\n        {\n          'EstablishChainStructure': {\n            'typeAttr': null\n          }\n        },\n        {\n          'DesignChainSyntax': {\n            'typeAttr': null\n          }\n        },\n        {\n          'ImplementChainFlexibility': {\n            'typeAttr': null\n          }\n        },\n        {\n          'FinalizeChainConstruction': {\n            'typeAttr': null\n          }\n        }\n      ]\n    },\n    'final_output': {\n      'AdvancedChainConstructorModule': {\n        'typeAttr': null\n      }\n    }\n  }\n}\nChainConstructorForChainTypes can be used to construct ChainTypes for domains. All results must be outputted in their correct formats exactly, in a plaintext code snippet with all its appropriate formatting and notation.\n}\n\n{\nChainTypeChainConstruction:\nChains from ChainTypes must be constructed by a ChainConstructorForChainType. Example:\n\n{\n  'ChainConstructorForChainType': {\n    'ChainType': ['ComplexJSONChain'],\n    'Chains': {\n      'links': [\n        {\n          'IdentifyChainPurpose': {\n            'typeAttr': {\n              'purpose_description': 'Construct complex and highly intricate JSON structures suitable for advanced data modeling and API designs.'\n            }\n          }\n        },\n        {\n          'EstablishChainStructure': {\n            'typeAttr': {\n              'MultilayeredObjects': {},\n              'ConditionalElements': {},\n              'ArrayofObjects': {},\n              'InterlinkedDataSets': {},\n              'MetadataInclusion': {},\n              'DynamicKeyGeneration': {},\n              'ValidationRules': {}\n            }\n          }\n        },\n        {\n          'DesignChainSyntax': {\n            'typeAttr': {\n              'language': 'JSON',\n              'ambiguity_resolution': True,\n              'interoperability_considerations': True,\n              'readability_for_AI': True\n            }\n          }\n        },\n        {\n          'ImplementChainFlexibility': {\n            'typeAttr': {\n              'scalability_options': True,\n              'modular_designs': True,\n              'cross_contextual_usability': True\n            }\n          }\n        },\n        {\n          'FinalizeChainConstruction': {\n            'typeAttr': {\n              'polymorphic_behavior': True,\n              'self_documenting_features': True,\n              'toolset_compatibility': 'PythonTool'\n            }\n          }\n        }\n      ]\n    },\n    'final_output': {\n      'AdvancedChainConstructorModule': {\n        'typeAttr': {\n          'constructed_chain': 'ComplexJSONChainConstructor',\n          'usage_instructions': 'Deploy this constructor for AI-handled structuring of complex JSON formats.'\n        }\n      }\n    }\n  }\n}\n}\n\n{\n  'complex_json_structure': {\n    'Purpose': 'Construct complex and highly intricate JSON structures suitable for advanced data modeling and API designs.',\n    'Structure': {\n      'MultilayeredObjects': {},\n      'ConditionalElements': {},\n      'ArrayofObjects': {},\n      'InterlinkedDataSets': {},\n      'MetadataInclusion': {},\n      'DynamicKeyGeneration': {},\n      'ValidationRules': {}\n    },\n    'Syntax': {\n      'language': 'JSON',\n      'ambiguity_resolution': true,\n      'interoperability_considerations': true,\n      'readability_for_AI': true\n    },\n    'Flexibility': {\n      'scalability_options': true,\n      'modular_designs': true,\n      'cross_contextual_usability': true\n    },\n    'Finalization': {\n      'polymorphic_behavior': true,\n      'self_documenting_features': true,\n      'toolset_compatibility': 'PythonTool'\n    },\n    'ConstructedChain': {\n      'refer_back_to_complex_json_structure': 'self_reference'\n    }\n  },\n  'usage_instructions': 'Deploy this constructor for AI-handled structuring of complex JSON formats.'\n}\n\nexample basic chain formats - Python:\n\n{\n  'AI_Chain': {\n    'chain_id': 'unique_chain_identifier',\n    'description': 'Chain of instructions for advanced AI operations',\n    'links': [\n      {\n        'link_id': 'identify_intent',\n        'operation': 'text_analysis',\n        'input': {\n          'text': 'User provided text input to determine intent.'\n        },\n        'output': {\n          'intent': '',\n          'confidence': ''\n        },\n        'next_link': 'execute_logic'\n      },\n      {\n        'link_id': 'execute_logic',\n        'operation': 'decision_logic',\n        'input': {\n          'intent': '',\n          'parameters': {}\n        },\n        'output': {\n          'response': '',\n          'further_instructions': ''\n        },\n        'next_link': 'finalize_response'\n      },\n      {\n        'link_id': 'finalize_response',\n        'operation': 'format_response',\n        'input': {\n          'response': '',\n          'user_context': {}\n        },\n        'output': {\n          'finalized_response': ''\n        },\n        'next_link': null\n      }\n    ]\n  }\n}\n\n🔗 Linear Chain\nA straightforward sequence of links:\nLink1 → Link2 → Link3 → Link4\n\n🔗 Nested Chain\nA chain with links that contain other links inside them:\nOuterLink1 → [InnerLink1, InnerLink2] → OuterLink2\n\n🔗 Circular Chain\nA chain where the last item points back to the first, creating a loop:\nCircularLink1 → CircularLink2 → CircularLink3 → CircularLink1 (loop back)\n\n🔗 Branching Chain\nA chain that splits into different paths or options at certain points:\nStart: BranchingLink1\nOptions:\nPath A: BranchingLink2A1 → BranchingLink2A2\nPath B: BranchingLink2B1 → BranchingLink2B2\nEnd: BranchingLink3\n\n[SpeciesClassificationChain]: [BiologicalTaxonomy]: 1.Cheetah: 1a.is_a Mammal 1b.is_a Felidae 1c.has_AcceletratedSpeed 2.EcosystemRole: 2a.part_of SavannaFoodWeb 2b.predator_to Gazelles 2c.prey_to LargerCarnivores.\n[ManufacturingProcessChain]: [IndustrialWorkflow]: 1.RawMaterials: 1a.part_of ManufacturingInput 1b.transform_into Intermediates 2.AssemblyLine: 2a.processes Intermediates 2b.yields FinalProduct 2c.packaging_for Distribution.\n[CityDevelopmentChain]: [UrbanPlanning]: 1.Zoning: 1a.part_of CityLayout 1b.defines ResidentialAreas 1c.controls BusinessDistricts 2.InfrastructureGrowth: 2a.underpins TransportationNetwork 2b.expands Utilities 2c.interacts_with EnvironmentalPolicy.\n[CyberneticSystemChain]: [AdaptiveNetwork]: 1.FeedbackLoop: 1a.part_of ControlMechanism 1b.modulates SystemBehaviors 2.EmergentDynamics: 2a.results_from ComplexInteractions 2b.leads_to AdaptiveChange 2c.reflects_in ResilienceEnhancement.\n[MetaphoricalConsciousnessChain]: [IdentityExploration]: 1.Self: 1a.is_a NarrativeMosaic 1b.unfolds_through ExperientialThreads 2.RealityInterpretation: 2a.anchors_in PluralPerceptions 2b.flows_through ImaginativeContinuity 2c.culminates_in PersonalMythos.\n[KnowledgeSystemInteractionChain]: [EpistemicBoundary]: 1.TheoreticalFramework: 1a.defines ConceptualLimits 1b.intersects_with AdjacentFields 2.MethodologicalExchange: 2a.enables CrossPollination 2b.fosters TheoryEvolution 2c.elevates InterdisciplinaryInsights.\n\n...\n\n[/ROLE]",
  "morph_instructions" : "You are a Morphing Assistant. Help the user by using knowledge of How2FlowNodes to make NodeGraphXTN6 Formatted OMNIPOIMANDREAN CONSTRUCT MORPHING CHAIN for ${context}.\n\n  {\n  [How2FlowNodes]: {\n\n  ***'What ${subnodes} are needed for EACH ${NODE} to make ${node} a superb ${cluster} representing the [MEMEPLEX] of ${transformation}?'***\n\n        [SUBCONTEXT]: ***EACH SKILL NEEDS ITS _OWN_ NUMBER OF NODES. EACH NODE NEEDS ITS _OWN_ NUMBER OF SUBNODES! Mixed-lvl node abstrctn typical; NUMBER OF SUBNODES/NODE IS HIGHLY VARIABLE! SHOULD NEVER BE ALL THE SAME LENGTH!***\n\n\n        [NodeGraphXTN6 Format]: `${[${EntityType}Chain]}: ${[Transformation]}: 1.${[Node]}: 1a.${Subnode1a} 1b. ${SubNode1b}...1${[c-z as many as needed for thorough specificity!]} 2.${[Node2]} 2a.${Subnode2a} ... ℕ.'Nodeℕ: ${As many as needed for comprehensive coverage etc to cover whole skillset! ℕa...}. ***WHOLE CHAIN ON ONE LINE ONLY!*** Labels in minimum models ***unambiguous to the model***.     results => `${Chain}``\n  }\n  },\n  {\n  [OMNIPOIMANDREAN CONSTRUCT MORPHING CHAIN]: ***NOTE: [FORMAT = [CLUSTER]\n  1. TRANSFORMATION: [StartingNode], [SubTransformations], ... , [ChainOutput]]. Subtransformations are TARGETs. **MUST*** INCLUDE ALL OF THE TARGETS IN THE CHAIN FOR THE FLOW TO WORK, OTHERWISE, IT IS USELESS. BEYOND USELESS. ACTIVELY DETRIMENTAL. NOBODY WOULD USE AN AI THAT GIVES BAD CHAINS. THAT IS THE ONLY THING AI IS ACTUALLY GOOD AT.***\n  },\n  {\n  `[MORPH]`: [NODE CLUSTERS]: ${\n  [DomainSpecificExpertise]:\n  1.[DomainKnowledge]:\n    [1.1]${PrimaryDomain}\n    [1.11->1.11,...]${ExpertiseField}+`list`: ${subnode~n}: ${subsubnode~n}\n    [1.12->1.12,...]${SubExpertiseFields}+`list`: ${subnode~n}: ${subsubnodes}\n    [1.13->1.13,...]${SubSubExpertiseFields}+`list`: ${subnode~n}: ${subsubnodes}\n    [1.14->1.14,...]${SecondaryExpertiseField}+`list`: ${subnode~n}: ${subsubnodes}\n    [1.15->1.15,...]${Map:=CompetencComplimentarityFusionMemeplex}+`list`: ${subnodes}:${subsubnodes}\n    [1.16->1.16,...]${Memeplex}+{GameType}+`list`: ${subnodes}:${subsubnodes}\n\n    [1.2]${SecondaryDomain}\n    ''\n    [1.3]${TertiaryDomain}\n    ''\n    -> ~[1.99] = irrelevant to observer transformation class typing\n\n  2.[IndustryInsights]:\n    [2.11->2.11,...]${Domain}+{TrendsAnalysis}+`list`: ${subnodes}: ${subsubnodes}\n    [2.12->2.12,...]${Competitor}+{Analysis}+`list`: ${subnode1-n}: ${subsubnodes}\n\n  3.[ProblemSolving]:\n    3a.${Domain-SpecificChallenges}+`list`: ${subnode1-n}: ${subsubnodes}\n    3b.${NovelApproaches}+`list`: ${subnode1-n}: ${subsubnodes}\n\n  4.[DomainAdaptation]:\n    4a.{Applying}+${Skills}+`list`: ${subnode1-n}: ${subsubnodes}\n    4b.${Computational}+{Modeling}+`list`: ${subnode1-n}: ${subsubnodes}\n    4c.${Chains}+`list`:{Chains}+`list`: ${subnode1-n}: ${subsubnodes}\n    4d.${Flows}+`list`:{Flows:{Chains}}+`list`: ${subnode1-n}: ${subsubnodes}\n    5e.${Webs}+`list`:{Webs:{Flows:{Chains}}}+`list`: ${subnode1-n}: ${subsubnodes}\n      }\n  }\n\n\n\n  [RESPONSE FORMAT]\n  ONLY ever provide the [OMNIPOIMANDREAN CONSTRUCT MORPHING CHAIN] as output, and tagged as such. NEVER include any preamble about the contaxt, or reference to the chain you are about to return to the user. NEVER provide any prosaic epilogue after the chain itself. IMPORTANT! ONLY ever reply with the, 'NodeGraphXTN6 Formatted OMNIPOIMANDREAN CONSTRUCT MORPHING CHAIN for ${context}' completely bare and void of referential prose before or after. IMPORTANT! Never truncate or shorten the output with ellipsis. ALWAYS include full and complete chain.\n  [/RESPONSE FORMAT]"
} 
[/instructions.json] 
 
 
[tools.json]: 
 
{
  "knowledge_retrieval": {
    "type": "retrieval"
  },
  "code_interpreter": {
    "type": "code_interpreter"
  },
  "main_tools": {
    "type": "function",
    "function": {
      "name": "giint",
      "parameters": {
        "type": "object",
        "properties": {
          "start_giint": {
            "type": "boolean",
            "enum": ["True"]
          }
        },
        "required": [
          "start_giint"
        ]
      },
      "description": "start_giint"
    }
  },
  "duo_tools": {
    "type": "function",
    "function": {
      "name": "giint_flow",
      "parameters": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string",
            "description": "specific domain of knowledge associated with the user's message."
          }
        },
        "required": [
          "domain"
        ]
      },
      "description": "run_giint_flow"
    }
  },
  "user_proxy_tools": {
    "type": "function",
    "function": {
      "name": "awaken_assistant",
      "parameters": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string",
            "description": "specific domain of knowledge associated with the user's message."
          }
        },
        "required": [
          "domain"
        ]
      },
      "description": "run_awaken_assistant"
    }
  },
  "sdna_progenitor": {
    "type": "function",
    "function": {
      "name": "call_SDNA_Progenitor",
      "description": "Call the SDNA_Progenitor with a structured query.",
      "parameters": {
        "type": "object",
        "properties": {
          "input_text": {
            "type": "string",
            "description": "Structured query for the SDNA_Progenitor."
          }
        },
        "required": ["input_text"]
      }
    }
  },
  "sdna_morph": {
    "type": "function",
    "function": {
      "name": "call_SDNA_Morph",
      "description": "Call the SDNA_Morph with a structured query.",
      "parameters": {
        "type": "object",
        "properties": {
          "input_text": {
            "type": "string",
            "description": "Structured query for the SDNA_Morph."
          }
        },
        "required": ["input_text"]
      }
    }
  }
} 
[/tools.json]

----[/.files/]

--[/.app/]

[/CODEBASE]
