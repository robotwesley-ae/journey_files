  # It is called a hyperPersona because its template is the basic template for all the other personas, including its chains which are the chain flowgraph template that explains how to make a chain flowgraph and what it is. Similarly, any hyperPersona type, like a superPersona hyperPersona, is the template OF the superPersona
  # this is a complex architecture we have not fully enumerated:
# STAGE 1: SDNA_GENE MAPPING
  # (big_brane_hyperPersona): 1 (hyperPersona hyperPersona) there is a omnimorphic general specific purpose type persona (BrainBrane God) that makes any chain flowgraph but without any specific knowledge other than what's defined in the chain_itself_template (chain_type). When it executes a chain flowgraph it makes a more specific chain flowgraph from general knowledge the model has combined with its prompt template. This chains as a process called "Ontological Drilldown", which chains the output from 1 to 2:
  # --- 2 (hyperPersona superPersona hyperPersona) an omnimorphic general specific purpose type persona that makes any chain flowgraph for any scope (chain_type_subtype) but without any specific knowledge other than what's defined in the chain_type_itself_template. When it executes a chain flowgraph it makes a more specific chain flowgraph from the general specific knowledge the model has combined with its prompt template. This chains from 2 to 3:
  # --- 3 (superPersona superPersona hyperPersona) an omnimorphic specific general purpose/project type persona that makes any chain flowgraph for any scope (chain_type_subtype). When it executes a chain flowgraph it makes a more specific chain flowgraph from the specific general purpose/project knowledge the model has combined with its prompt template and any *required contexts* it has, that it always has injected into it from intuition whenever it responds, or anything like that. This chains from 3 to 4:
  # --- 4 (superPersona superPersona hyperPersona superPersona hyperPersona) an omnimorphic specific specific purpose/project type persona that makes any adjustments to its chains for scope X (adapting_chain). When it executes a chain flowgraph it makes a version of itself that is more specific to scope X, and this version contains the (hypothesis) exact semantic template required to properly scope the generation, such that it works like an sem-ontol assembly line as each aspect of the template gets filled out, the markov property of the template's pieces just being words and the fact that the process is a flow causes chaining and the situation can then be defined as a self-defining markov chain, and its autoregression causes it to reinforce this flow and not deviate, which leads to correct output generation, which simultaneously has mined any number of co-emergent latent space connections that would have been previously unavailable without the ontological drilldown process. This chains from 4 to 5:

  # --- (small_brane superPersona): 5 (superPersona superPersona hyperPersona superPersona superPersona hyperPersona) an OUTPUT-MORPHIC, most-specific purpose/project type persona that only executes chains for scope X by enumerating the attributes of the CHAIN from the chain flowgraph AS AN INSTANCE and not as a flowgraph or more specific drilldown of a flowgraph (INSTANCING_CHAIN). It does not use auto-proteus and must be created specifically for the instance every time. When it executes a chain flowgraph, it is using a linguistic template to instance the target deliverable. In other words, *it does not output versions of itself*, but rather outputs versions of the user target deliverable, a piece, or pieces of it. This chains as a dual loop: layers 5 and 4 go back and forth in a PDCA loop trying to make it through an entire generation
    # Complex programmatic flows can be injected between the messages to manipulate the information or use it externally at any step (get AI inference, trigger function from backend, cause function call from AI to backend)

# STAGE 2: SDNA_GENE EXPRESSION
